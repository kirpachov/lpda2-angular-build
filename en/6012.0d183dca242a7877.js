(self.webpackChunklpda2=self.webpackChunklpda2||[]).push([[6012],{6012:(z,U,F)=>{"use strict";F.d(U,{s:()=>l});var N=F(4704),L=F(8776);function T(y,d=!0){const e=L.object({items:L.array().items(L.object()).required(),metadata:L.object().required()}).validate(y);return e.error&&d&&console.error("Invalid search result data:",{validationErrors:e.error,data:y}),y instanceof Object&&2===Object.keys(y).length&&-1!==Object.keys(y).indexOf("items")&&-1!==Object.keys(y).indexOf("metadata")&&null==e.error}class j{constructor(d,f){this.items=d.items.map(e=>new f(e)),T(d),this.metadata=d.metadata}get hasItems(){return typeof Array.isArray(this.items)&&this.items.length>0}get current_page(){return this.metadata.current_page}get per_page(){return this.metadata.per_page}get prev_page(){return this.metadata.prev_page}get next_page(){return this.metadata.next_page}get total_pages(){return this.metadata.total_pages}get total_count(){return this.metadata.total_count}get has_next(){return null!=this.next_page}get has_prev(){return null!=this.prev_page}get isEmpty(){return!(this.items&&this.items.length>0)}}var $=F(6772),b=F(4496);let l=(()=>{class y extends $.A{constructor(f,e){super(e),this.type=f}show(f){return this.get(`${f}`).pipe((0,N.k)(e=>this.mapItem(e)))}search(f={}){return this.get("",{params:f}).pipe((0,N.k)(e=>this.mapItems(e)))}create(f){return this.post("",f).pipe((0,N.k)(e=>this.mapItem(e)))}update(f,e){return this.patch(`${f}`,e).pipe((0,N.k)(i=>this.mapItem(i)))}destroy(f){return this.delete(`${f}`)}mapItem(f){if(!this.type)throw new Error(`this.type is not defined for ${this.constructor.name}!`);if("object"!=typeof f||null==f)throw new Error(`Invalid data type for ${this.constructor.name}!`);return"object"==typeof f.item&&null!=f.item||console.error(`Invalid data type for ${this.constructor.name}!`,f),new this.type(f.item)}mapItems(f){if(!this.type)throw new Error(`this.type is not defined for ${this.constructor.name}!`);if(!T(f))throw new Error(`Invalid data type for ${this.constructor.name}!`);return new j(f,this.type)}static#e=this.\u0275fac=function(e){b.KEo()};static#t=this.\u0275prov=b.wxM({token:y,factory:y.\u0275fac,providedIn:"root"})}return y})()},8776:(z,U,F)=>{var L,T,N=F(1196).default;self,z.exports=(L={7629:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(9474),f=b(1687),e=b(8652),i=b(8160),n=b(3292),r=b(6354),t=b(8901),o=b(9708),s=b(6914),a=b(2294),c=b(6133),h=b(1152),p=b(8863),_=b(2036),v={Base:class{constructor(u){this.type=u,this.$_root=null,this._definition={},this._reset()}_reset(){this._ids=new a.Ids,this._preferences=null,this._refs=new c.Manager,this._cache=null,this._valids=null,this._invalids=null,this._flags={},this._rules=[],this._singleRules=new Map,this.$_terms={},this.$_temp={ruleset:null,whens:{}}}describe(){return l("function"==typeof o.describe,"Manifest functionality disabled"),o.describe(this)}allow(...u){return i.verifyFlat(u,"allow"),this._values(u,"_valids")}alter(u){l(u&&"object"==typeof u&&!Array.isArray(u),"Invalid targets argument"),l(!this._inRuleset(),"Cannot set alterations inside a ruleset");const m=this.clone();m.$_terms.alterations=m.$_terms.alterations||[];for(const g in u){const w=u[g];l("function"==typeof w,"Alteration adjuster for",g,"must be a function"),m.$_terms.alterations.push({target:g,adjuster:w})}return m.$_temp.ruleset=!1,m}artifact(u){return l(void 0!==u,"Artifact cannot be undefined"),l(!this._cache,"Cannot set an artifact with a rule cache"),this.$_setFlag("artifact",u)}cast(u){return l(!1===u||"string"==typeof u,"Invalid to value"),l(!1===u||this._definition.cast[u],"Type",this.type,"does not support casting to",u),this.$_setFlag("cast",!1===u?void 0:u)}default(u,m){return this._default("default",u,m)}description(u){return l(u&&"string"==typeof u,"Description must be a non-empty string"),this.$_setFlag("description",u)}empty(u){const m=this.clone();return void 0!==u&&(u=m.$_compile(u,{override:!1})),m.$_setFlag("empty",u,{clone:!1})}error(u){return l(u,"Missing error"),l(u instanceof Error||"function"==typeof u,"Must provide a valid Error object or a function"),this.$_setFlag("error",u)}example(u,m={}){return l(void 0!==u,"Missing example"),i.assertOptions(m,["override"]),this._inner("examples",u,{single:!0,override:m.override})}external(u,m){return"object"==typeof u&&(l(!m,"Cannot combine options with description"),m=u.description,u=u.method),l("function"==typeof u,"Method must be a function"),l(void 0===m||m&&"string"==typeof m,"Description must be a non-empty string"),this._inner("externals",{method:u,description:m},{single:!0})}failover(u,m){return this._default("failover",u,m)}forbidden(){return this.presence("forbidden")}id(u){return u?(l("string"==typeof u,"id must be a non-empty string"),l(/^[^\.]+$/.test(u),"id cannot contain period character"),this.$_setFlag("id",u)):this.$_setFlag("id",void 0)}invalid(...u){return this._values(u,"_invalids")}label(u){return l(u&&"string"==typeof u,"Label name must be a non-empty string"),this.$_setFlag("label",u)}meta(u){return l(void 0!==u,"Meta cannot be undefined"),this._inner("metas",u,{single:!0})}note(...u){l(u.length,"Missing notes");for(const m of u)l(m&&"string"==typeof m,"Notes must be non-empty strings");return this._inner("notes",u)}only(u=!0){return l("boolean"==typeof u,"Invalid mode:",u),this.$_setFlag("only",u)}optional(){return this.presence("optional")}prefs(u){l(u,"Missing preferences"),l(void 0===u.context,"Cannot override context"),l(void 0===u.externals,"Cannot override externals"),l(void 0===u.warnings,"Cannot override warnings"),l(void 0===u.debug,"Cannot override debug"),i.checkPreferences(u);const m=this.clone();return m._preferences=i.preferences(m._preferences,u),m}presence(u){return l(["optional","required","forbidden"].includes(u),"Unknown presence mode",u),this.$_setFlag("presence",u)}raw(u=!0){return this.$_setFlag("result",u?"raw":void 0)}result(u){return l(["raw","strip"].includes(u),"Unknown result mode",u),this.$_setFlag("result",u)}required(){return this.presence("required")}strict(u){const m=this.clone();return m._preferences=i.preferences(m._preferences,{convert:void 0!==u&&!u}),m}strip(u=!0){return this.$_setFlag("result",u?"strip":void 0)}tag(...u){l(u.length,"Missing tags");for(const m of u)l(m&&"string"==typeof m,"Tags must be non-empty strings");return this._inner("tags",u)}unit(u){return l(u&&"string"==typeof u,"Unit name must be a non-empty string"),this.$_setFlag("unit",u)}valid(...u){i.verifyFlat(u,"valid");const m=this.allow(...u);return m.$_setFlag("only",!!m._valids,{clone:!1}),m}when(u,m){const g=this.clone();g.$_terms.whens||(g.$_terms.whens=[]);const w=n.when(g,u,m);if(!["any","link"].includes(g.type)){const x=w.is?[w]:w.switch;for(const k of x)l(!k.then||"any"===k.then.type||k.then.type===g.type,"Cannot combine",g.type,"with",k.then&&k.then.type),l(!k.otherwise||"any"===k.otherwise.type||k.otherwise.type===g.type,"Cannot combine",g.type,"with",k.otherwise&&k.otherwise.type)}return g.$_terms.whens.push(w),g.$_mutateRebuild()}cache(u){l(!this._inRuleset(),"Cannot set caching inside a ruleset"),l(!this._cache,"Cannot override schema cache"),l(void 0===this._flags.artifact,"Cannot cache a rule with an artifact");const m=this.clone();return m._cache=u||e.provider.provision(),m.$_temp.ruleset=!1,m}clone(){const u=Object.create(Object.getPrototypeOf(this));return this._assign(u)}concat(u){l(i.isSchema(u),"Invalid schema object"),l("any"===this.type||"any"===u.type||u.type===this.type,"Cannot merge type",this.type,"with another type:",u.type),l(!this._inRuleset(),"Cannot concatenate onto a schema with open ruleset"),l(!u._inRuleset(),"Cannot concatenate a schema with open ruleset");let m=this.clone();if("any"===this.type&&"any"!==u.type){const g=u.clone();for(const w of Object.keys(m))"type"!==w&&(g[w]=m[w]);m=g}m._ids.concat(u._ids),m._refs.register(u,c.toSibling),m._preferences=m._preferences?i.preferences(m._preferences,u._preferences):u._preferences,m._valids=_.merge(m._valids,u._valids,u._invalids),m._invalids=_.merge(m._invalids,u._invalids,u._valids);for(const g of u._singleRules.keys())m._singleRules.has(g)&&(m._rules=m._rules.filter(w=>w.keep||w.name!==g),m._singleRules.delete(g));for(const g of u._rules)u._definition.rules[g.method].multi||m._singleRules.set(g.name,g),m._rules.push(g);if(m._flags.empty&&u._flags.empty){m._flags.empty=m._flags.empty.concat(u._flags.empty);const g=Object.assign({},u._flags);delete g.empty,f(m._flags,g)}else if(u._flags.empty){m._flags.empty=u._flags.empty;const g=Object.assign({},u._flags);delete g.empty,f(m._flags,g)}else f(m._flags,u._flags);for(const g in u.$_terms){const w=u.$_terms[g];w?m.$_terms[g]=m.$_terms[g]?m.$_terms[g].concat(w):w.slice():m.$_terms[g]||(m.$_terms[g]=w)}return this.$_root._tracer&&this.$_root._tracer._combine(m,[this,u]),m.$_mutateRebuild()}extend(u){return l(!u.base,"Cannot extend type with another base"),t.type(this,u)}extract(u){return u=Array.isArray(u)?u:u.split("."),this._ids.reach(u)}fork(u,m){l(!this._inRuleset(),"Cannot fork inside a ruleset");let g=this;for(let w of[].concat(u))w=Array.isArray(w)?w:w.split("."),g=g._ids.fork(w,m,g);return g.$_temp.ruleset=!1,g}rule(u){const m=this._definition;i.assertOptions(u,Object.keys(m.modifiers)),l(!1!==this.$_temp.ruleset,"Cannot apply rules to empty ruleset or the last rule added does not support rule properties");const g=null===this.$_temp.ruleset?this._rules.length-1:this.$_temp.ruleset;l(g>=0&&g<this._rules.length,"Cannot apply rules to empty ruleset");const w=this.clone();for(let x=g;x<w._rules.length;++x){const k=w._rules[x],R=y(k);for(const S in u)m.modifiers[S](R,u[S]),l(R.name===k.name,"Cannot change rule name");w._rules[x]=R,w._singleRules.get(R.name)===k&&w._singleRules.set(R.name,R)}return w.$_temp.ruleset=!1,w.$_mutateRebuild()}get ruleset(){l(!this._inRuleset(),"Cannot start a new ruleset without closing the previous one");const u=this.clone();return u.$_temp.ruleset=u._rules.length,u}get $(){return this.ruleset}tailor(u){u=[].concat(u),l(!this._inRuleset(),"Cannot tailor inside a ruleset");let m=this;if(this.$_terms.alterations)for(const{target:g,adjuster:w}of this.$_terms.alterations)u.includes(g)&&(m=w(m),l(i.isSchema(m),"Alteration adjuster for",g,"failed to return a schema object"));return m=m.$_modify({each:g=>g.tailor(u),ref:!1}),m.$_temp.ruleset=!1,m.$_mutateRebuild()}tracer(){return h.location?h.location(this):this}validate(u,m){return p.entry(u,this,m)}validateAsync(u,m){return p.entryAsync(u,this,m)}$_addRule(u){"string"==typeof u&&(u={name:u}),l(u&&"object"==typeof u,"Invalid options"),l(u.name&&"string"==typeof u.name,"Invalid rule name");for(const k in u)l("_"!==k[0],"Cannot set private rule properties");const m=Object.assign({},u);m._resolve=[],m.method=m.method||m.name;const g=this._definition.rules[m.method],w=m.args;l(g,"Unknown rule",m.method);const x=this.clone();if(w){l(1===Object.keys(w).length||Object.keys(w).length===this._definition.rules[m.name].args.length,"Invalid rule definition for",this.type,m.name);for(const k in w){let R=w[k];if(g.argsByName){const S=g.argsByName.get(k);if(S.ref&&i.isResolvable(R))m._resolve.push(k),x.$_mutateRegister(R);else if(S.normalize&&(R=S.normalize(R),w[k]=R),S.assert){const E=i.validateArg(R,k,S);l(!E,E,"or reference")}}void 0!==R?w[k]=R:delete w[k]}}return g.multi||(x._ruleRemove(m.name,{clone:!1}),x._singleRules.set(m.name,m)),!1===x.$_temp.ruleset&&(x.$_temp.ruleset=null),g.priority?x._rules.unshift(m):x._rules.push(m),x}$_compile(u,m){return n.schema(this.$_root,u,m)}$_createError(u,m,g,w,x,k={}){const R=!1!==k.flags?this._flags:{},S=k.messages?s.merge(this._definition.messages,k.messages):this._definition.messages;return new r.Report(u,m,g,R,S,w,x)}$_getFlag(u){return this._flags[u]}$_getRule(u){return this._singleRules.get(u)}$_mapLabels(u){return u=Array.isArray(u)?u:u.split("."),this._ids.labels(u)}$_match(u,m,g,w){(g=Object.assign({},g)).abortEarly=!0,g._externals=!1,m.snapshot();const x=!p.validate(u,this,m,g,w).errors;return m.restore(),x}$_modify(u){return i.assertOptions(u,["each","once","ref","schema"]),a.schema(this,u)||this}$_mutateRebuild(){return l(!this._inRuleset(),"Cannot add this rule inside a ruleset"),this._refs.reset(),this._ids.reset(),this.$_modify({each:(u,{source:m,name:g,key:x})=>{const k=this._definition[m][g]&&this._definition[m][g].register;!1!==k&&this.$_mutateRegister(u,{family:k,key:x})}}),this._definition.rebuild&&this._definition.rebuild(this),this.$_temp.ruleset=!1,this}$_mutateRegister(u,{family:m,key:g}={}){this._refs.register(u,m),this._ids.register(u,{key:g})}$_property(u){return this._definition.properties[u]}$_reach(u){return this._ids.reach(u)}$_rootReferences(){return this._refs.roots()}$_setFlag(u,m,g={}){if(l("_"===u[0]||!this._inRuleset(),"Cannot set flag inside a ruleset"),d(m,(this._definition.flags[u]||{}).default)&&(m=void 0),d(m,this._flags[u]))return this;const x=!1!==g.clone?this.clone():this;return void 0!==m?(x._flags[u]=m,x.$_mutateRegister(m)):delete x._flags[u],"_"!==u[0]&&(x.$_temp.ruleset=!1),x}$_parent(u,...m){return this[u][i.symbols.parent].call(this,...m)}$_validate(u,m,g){return p.validate(u,this,m,g)}_assign(u){u.type=this.type,u.$_root=this.$_root,u.$_temp=Object.assign({},this.$_temp),u.$_temp.whens={},u._ids=this._ids.clone(),u._preferences=this._preferences,u._valids=this._valids&&this._valids.clone(),u._invalids=this._invalids&&this._invalids.clone(),u._rules=this._rules.slice(),u._singleRules=y(this._singleRules,{shallow:!0}),u._refs=this._refs.clone(),u._flags=Object.assign({},this._flags),u._cache=null,u.$_terms={};for(const m in this.$_terms)u.$_terms[m]=this.$_terms[m]?this.$_terms[m].slice():null;u.$_super={};for(const m in this.$_super)u.$_super[m]=this._super[m].bind(u);return u}_bare(){const u=this.clone();u._reset();const m=u._definition.terms;for(const g in m)u.$_terms[g]=m[g].init;return u.$_mutateRebuild()}_default(u,m,g={}){return i.assertOptions(g,"literal"),l(void 0!==m,"Missing",u,"value"),l("function"==typeof m||!g.literal,"Only function value supports literal option"),"function"==typeof m&&g.literal&&(m={[i.symbols.literal]:!0,literal:m}),this.$_setFlag(u,m)}_generate(u,m,g){if(!this.$_terms.whens)return{schema:this};const w=[],x=[];for(let S=0;S<this.$_terms.whens.length;++S){const E=this.$_terms.whens[S];if(E.concat){w.push(E.concat),x.push(`${S}.concat`);continue}const D=E.ref?E.ref.resolve(u,m,g):u,I=E.is?[E]:E.switch,M=x.length;for(let A=0;A<I.length;++A){const{is:O,then:C,otherwise:P}=I[A],q=`${S}${E.switch?"."+A:""}`;if(O.$_match(D,m.nest(O,`${q}.is`),g)){if(C){const V=m.localize([...m.path,`${q}.then`],m.ancestors,m.schemas),{schema:B,id:W}=C._generate(u,V,g);w.push(B),x.push(`${q}.then${W?`(${W})`:""}`);break}}else if(P){const V=m.localize([...m.path,`${q}.otherwise`],m.ancestors,m.schemas),{schema:B,id:W}=P._generate(u,V,g);w.push(B),x.push(`${q}.otherwise${W?`(${W})`:""}`);break}}if(E.break&&x.length>M)break}const k=x.join(", ");if(m.mainstay.tracer.debug(m,"rule","when",k),!k)return{schema:this};if(!m.mainstay.tracer.active&&this.$_temp.whens[k])return{schema:this.$_temp.whens[k],id:k};let R=this;this._definition.generate&&(R=this._definition.generate(this,u,m,g));for(const S of w)R=R.concat(S);return this.$_root._tracer&&this.$_root._tracer._combine(R,[this,...w]),this.$_temp.whens[k]=R,{schema:R,id:k}}_inner(u,m,g={}){l(!this._inRuleset(),`Cannot set ${u} inside a ruleset`);const w=this.clone();return w.$_terms[u]&&!g.override||(w.$_terms[u]=[]),g.single?w.$_terms[u].push(m):w.$_terms[u].push(...m),w.$_temp.ruleset=!1,w}_inRuleset(){return null!==this.$_temp.ruleset&&!1!==this.$_temp.ruleset}_ruleRemove(u,m={}){if(!this._singleRules.has(u))return this;const g=!1!==m.clone?this.clone():this;g._singleRules.delete(u);const w=[];for(let x=0;x<g._rules.length;++x){const k=g._rules[x];k.name!==u||k.keep?w.push(k):g._inRuleset()&&x<g.$_temp.ruleset&&--g.$_temp.ruleset}return g._rules=w,g}_values(u,m){i.verifyFlat(u,m.slice(1,-1));const g=this.clone(),w=u[0]===i.symbols.override;if(w&&(u=u.slice(1)),!g[m]&&u.length?g[m]=new _:w&&(g[m]=u.length?new _:null,g.$_mutateRebuild()),!g[m])return g;w&&g[m].override();for(const x of u){l(void 0!==x,"Cannot call allow/valid/invalid with undefined"),l(x!==i.symbols.override,"Override must be the first value");const k="_invalids"===m?"_valids":"_invalids";g[k]&&(g[k].remove(x),g[k].length||(l("_valids"===m||!g._flags.only,"Setting invalid value",x,"leaves schema rejecting all values due to previous valid rule"),g[k]=null)),g[m].add(x,g._refs)}return g}}};v.Base.prototype[i.symbols.any]={version:i.version,compile:n.compile,root:"$_root"},v.Base.prototype.isImmutable=!0,v.Base.prototype.deny=v.Base.prototype.invalid,v.Base.prototype.disallow=v.Base.prototype.invalid,v.Base.prototype.equal=v.Base.prototype.valid,v.Base.prototype.exist=v.Base.prototype.required,v.Base.prototype.not=v.Base.prototype.invalid,v.Base.prototype.options=v.Base.prototype.prefs,v.Base.prototype.preferences=v.Base.prototype.prefs,j.exports=new v.Base},8652:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(8160),f={max:1e3,supported:new Set(["undefined","boolean","number","string"])};$.provider={provision:e=>new f.Cache(e)},f.Cache=class{constructor(e={}){d.assertOptions(e,["max"]),l(void 0===e.max||e.max&&e.max>0&&isFinite(e.max),"Invalid max cache size"),this._max=e.max||f.max,this._map=new Map,this._list=new f.List}get length(){return this._map.size}set(e,i){if(null!==e&&!f.supported.has(typeof e))return;let n=this._map.get(e);if(n)return n.value=i,void this._list.first(n);n=this._list.unshift({key:e,value:i}),this._map.set(e,n),this._compact()}get(e){const i=this._map.get(e);if(i)return this._list.first(i),y(i.value)}_compact(){if(this._map.size>this._max){const e=this._list.pop();this._map.delete(e.key)}}},f.List=class{constructor(){this.tail=null,this.head=null}unshift(e){return e.next=null,e.prev=this.head,this.head&&(this.head.next=e),this.head=e,this.tail||(this.tail=e),e}first(e){e!==this.head&&(this._remove(e),this.unshift(e))}pop(){return this._remove(this.tail)}_remove(e){const{next:i,prev:n}=e;return i.prev=n,n&&(n.next=i),e===this.tail&&(this.tail=i),e.prev=null,e.next=null,e}}},8160:(j,$,b)=>{"use strict";const l=b(375),y=b(7916),d=b(5934);let f,e;const i={isoDate:/^(?:[-+]\d{2})?(?:\d{4}(?!\d{2}\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\1(?:[12]\d|0[1-9]|3[01]))?|W(?:[0-4]\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\d|[12]\d{2}|3(?:[0-5]\d|6[1-6])))(?![T]$|[T][\d]+Z$)(?:[T\s](?:(?:(?:[01]\d|2[0-3])(?:(:?)[0-5]\d)?|24\:?00)(?:[.,]\d+(?!:))?)(?:\2[0-5]\d(?:[.,]\d+)?)?(?:[Z]|(?:[+-])(?:[01]\d|2[0-3])(?::?[0-5]\d)?)?)?)?$/};$.version=d.version,$.defaults={abortEarly:!0,allowUnknown:!1,artifacts:!1,cache:!0,context:null,convert:!0,dateFormat:"iso",errors:{escapeHtml:!1,label:"path",language:null,render:!0,stack:!1,wrap:{label:'"',array:"[]"}},externals:!0,messages:{},nonEnumerables:!1,noDefaults:!1,presence:"optional",skipFunctions:!1,stripUnknown:!1,warnings:!1},$.symbols={any:Symbol.for("@hapi/joi/schema"),arraySingle:Symbol("arraySingle"),deepDefault:Symbol("deepDefault"),errors:Symbol("errors"),literal:Symbol("literal"),override:Symbol("override"),parent:Symbol("parent"),prefs:Symbol("prefs"),ref:Symbol("ref"),template:Symbol("template"),values:Symbol("values")},$.assertOptions=function(n,r,t="Options"){l(n&&"object"==typeof n&&!Array.isArray(n),"Options must be of type object");const o=Object.keys(n).filter(s=>!r.includes(s));l(0===o.length,`${t} contain unknown keys: ${o}`)},$.checkPreferences=function(n){e=e||b(3378);const r=e.preferences.validate(n);if(r.error)throw new y([r.error.details[0].message])},$.compare=function(n,r,t){switch(t){case"=":return n===r;case">":return n>r;case"<":return n<r;case">=":return n>=r;case"<=":return n<=r}},$.default=function(n,r){return void 0===n?r:n},$.isIsoDate=function(n){return i.isoDate.test(n)},$.isNumber=function(n){return"number"==typeof n&&!isNaN(n)},$.isResolvable=function(n){return!!n&&(n[$.symbols.ref]||n[$.symbols.template])},$.isSchema=function(n,r={}){const t=n&&n[$.symbols.any];return!!t&&(l(r.legacy||t.version===$.version,"Cannot mix different versions of joi schemas"),!0)},$.isValues=function(n){return n[$.symbols.values]},$.limit=function(n){return Number.isSafeInteger(n)&&n>=0},$.preferences=function(n,r){f=f||b(6914),n=n||{},r=r||{};const t=Object.assign({},n,r);return r.errors&&n.errors&&(t.errors=Object.assign({},n.errors,r.errors),t.errors.wrap=Object.assign({},n.errors.wrap,r.errors.wrap)),r.messages&&(t.messages=f.compile(r.messages,n.messages)),delete t[$.symbols.prefs],t},$.tryWithPath=function(n,r,t={}){try{return n()}catch(o){throw o.path=void 0!==o.path?r+"."+o.path:r,t.append&&(o.message=`${o.message} (${o.path})`),o}},$.validateArg=function(n,r,{assert:t,message:o}){if($.isSchema(t)){const s=t.validate(n);return s.error?s.error.message:void 0}if(!t(n))return r?`${r} ${o}`:o},$.verifyFlat=function(n,r){for(const t of n)l(!Array.isArray(t),"Method no longer accepts array arguments:",r)}},3292:(j,$,b)=>{"use strict";const l=b(375),y=b(8160),d=b(6133),f={};$.schema=function(e,i,n={}){y.assertOptions(n,["appendPath","override"]);try{return f.schema(e,i,n)}catch(r){throw n.appendPath&&void 0!==r.path&&(r.message=`${r.message} (${r.path})`),r}},f.schema=function(e,i,n){l(void 0!==i,"Invalid undefined schema"),Array.isArray(i)&&(l(i.length,"Invalid empty array schema"),1===i.length&&(i=i[0]));const r=(t,...o)=>!1!==n.override?t.valid(e.override,...o):t.valid(...o);if(f.simple(i))return r(e,i);if("function"==typeof i)return e.custom(i);if(l("object"==typeof i,"Invalid schema content:",typeof i),y.isResolvable(i))return r(e,i);if(y.isSchema(i))return i;if(Array.isArray(i)){for(const t of i)if(!f.simple(t))return e.alternatives().try(...i);return r(e,...i)}return i instanceof RegExp?e.string().regex(i):i instanceof Date?r(e.date(),i):(l(Object.getPrototypeOf(i)===Object.getPrototypeOf({}),"Schema can only contain plain objects"),e.object().keys(i))},$.ref=function(e,i){return d.isRef(e)?e:d.create(e,i)},$.compile=function(e,i,n={}){y.assertOptions(n,["legacy"]);const r=i&&i[y.symbols.any];if(r)return l(n.legacy||r.version===y.version,"Cannot mix different versions of joi schemas:",r.version,y.version),i;if("object"!=typeof i||!n.legacy)return $.schema(e,i,{appendPath:!0});const t=f.walk(i);return t?t.compile(t.root,i):$.schema(e,i,{appendPath:!0})},f.walk=function(e){if("object"!=typeof e)return null;if(Array.isArray(e)){for(const n of e){const r=f.walk(n);if(r)return r}return null}const i=e[y.symbols.any];if(i)return{root:e[i.root],compile:i.compile};l(Object.getPrototypeOf(e)===Object.getPrototypeOf({}),"Schema can only contain plain objects");for(const n in e){const r=f.walk(e[n]);if(r)return r}return null},f.simple=function(e){return null===e||["boolean","string","number"].includes(typeof e)},$.when=function(e,i,n){if(void 0===n&&(l(i&&"object"==typeof i,"Missing options"),n=i,i=d.create(".")),Array.isArray(n)&&(n={switch:n}),y.assertOptions(n,["is","not","then","otherwise","switch","break"]),y.isSchema(i))return l(void 0===n.is,'"is" can not be used with a schema condition'),l(void 0===n.not,'"not" can not be used with a schema condition'),l(void 0===n.switch,'"switch" can not be used with a schema condition'),f.condition(e,{is:i,then:n.then,otherwise:n.otherwise,break:n.break});if(l(d.isRef(i)||"string"==typeof i,"Invalid condition:",i),l(void 0===n.not||void 0===n.is,'Cannot combine "is" with "not"'),void 0===n.switch){let t=n;void 0!==n.not&&(t={is:n.not,then:n.otherwise,otherwise:n.then,break:n.break});let o=void 0!==t.is?e.$_compile(t.is):e.$_root.invalid(null,!1,0,"").required();return l(void 0!==t.then||void 0!==t.otherwise,'options must have at least one of "then", "otherwise", or "switch"'),l(void 0===t.break||void 0===t.then||void 0===t.otherwise,"Cannot specify then, otherwise, and break all together"),void 0===n.is||d.isRef(n.is)||y.isSchema(n.is)||(o=o.required()),f.condition(e,{ref:$.ref(i),is:o,then:t.then,otherwise:t.otherwise,break:t.break})}l(Array.isArray(n.switch),'"switch" must be an array'),l(void 0===n.is,'Cannot combine "switch" with "is"'),l(void 0===n.not,'Cannot combine "switch" with "not"'),l(void 0===n.then,'Cannot combine "switch" with "then"');const r={ref:$.ref(i),switch:[],break:n.break};for(let t=0;t<n.switch.length;++t){const o=n.switch[t],s=t===n.switch.length-1;y.assertOptions(o,s?["is","then","otherwise"]:["is","then"]),l(void 0!==o.is,'Switch statement missing "is"'),l(void 0!==o.then,'Switch statement missing "then"');const a={is:e.$_compile(o.is),then:e.$_compile(o.then)};if(d.isRef(o.is)||y.isSchema(o.is)||(a.is=a.is.required()),s){l(void 0===n.otherwise||void 0===o.otherwise,'Cannot specify "otherwise" inside and outside a "switch"');const c=void 0!==n.otherwise?n.otherwise:o.otherwise;void 0!==c&&(l(void 0===r.break,"Cannot specify both otherwise and break"),a.otherwise=e.$_compile(c))}r.switch.push(a)}return r},f.condition=function(e,i){for(const n of["then","otherwise"])void 0===i[n]?delete i[n]:i[n]=e.$_compile(i[n]);return i}},6354:(j,$,b)=>{"use strict";const l=b(5688),y=b(8160),d=b(3328);$.Report=class{constructor(f,e,i,n,r,t,o){if(this.code=f,this.flags=n,this.messages=r,this.path=t.path,this.prefs=o,this.state=t,this.value=e,this.message=null,this.template=null,this.local=i||{},this.local.label=$.label(this.flags,this.state,this.prefs,this.messages),void 0===this.value||this.local.hasOwnProperty("value")||(this.local.value=this.value),this.path.length){const s=this.path[this.path.length-1];"object"!=typeof s&&(this.local.key=s)}}_setTemplate(f){if(this.template=f,!this.flags.label&&0===this.path.length){const e=this._template(this.template,"root");e&&(this.local.label=e)}}toString(){if(this.message)return this.message;const f=this.code;if(!this.prefs.errors.render)return this.code;const e=this._template(this.template)||this._template(this.prefs.messages)||this._template(this.messages);return void 0===e?`Error code "${f}" is not defined, your custom type is missing the correct messages definition`:(this.message=e.render(this.value,this.state,this.prefs,this.local,{errors:this.prefs.errors,messages:[this.prefs.messages,this.messages]}),this.prefs.errors.label||(this.message=this.message.replace(/^"" /,"").trim()),this.message)}_template(f,e){return $.template(this.value,f,e||this.code,this.state,this.prefs)}},$.path=function(f){let e="";for(const i of f)"object"!=typeof i&&("string"==typeof i?(e&&(e+="."),e+=i):e+=`[${i}]`);return e},$.template=function(f,e,i,n,r){if(!e)return;if(d.isTemplate(e))return"root"!==i?e:null;let t=r.errors.language;if(y.isResolvable(t)&&(t=t.resolve(f,n,r)),t&&e[t]){if(void 0!==e[t][i])return e[t][i];if(void 0!==e[t]["*"])return e[t]["*"]}return e[i]?e[i]:e["*"]},$.label=function(f,e,i,n){if(f.label)return f.label;if(!i.errors.label)return"";let r=e.path;return"key"===i.errors.label&&e.path.length>1&&(r=e.path.slice(-1)),$.path(r)||$.template(null,i.messages,"root",e,i)||n&&$.template(null,n,"root",e,i)||"value"},$.process=function(f,e,i){if(!f)return null;const{override:n,message:r,details:t}=$.details(f);if(n)return n;if(i.errors.stack)return new $.ValidationError(r,t,e);const o=Error.stackTraceLimit;Error.stackTraceLimit=0;const s=new $.ValidationError(r,t,e);return Error.stackTraceLimit=o,s},$.details=function(f,e={}){let i=[];const n=[];for(const r of f){if(r instanceof Error){if(!1!==e.override)return{override:r};const o=r.toString();i.push(o),n.push({message:o,type:"override",context:{error:r}});continue}const t=r.toString();i.push(t),n.push({message:t,path:r.path.filter(o=>"object"!=typeof o),type:r.code,context:r.local})}return i.length>1&&(i=[...new Set(i)]),{message:i.join(". "),details:n}},$.ValidationError=class extends Error{constructor(f,e,i){super(f),this._original=i,this.details=e}static isError(f){return f instanceof $.ValidationError}},$.ValidationError.prototype.isJoi=!0,$.ValidationError.prototype.name="ValidationError",$.ValidationError.prototype.annotate=l.error},8901:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(8160),f=b(6914),e={};$.type=function(i,n){const r=Object.getPrototypeOf(i),t=y(r),o=i._assign(Object.create(t)),s=Object.assign({},n);delete s.base,t._definition=s;const a=r._definition||{};s.messages=f.merge(a.messages,s.messages),s.properties=Object.assign({},a.properties,s.properties),o.type=s.type,s.flags=Object.assign({},a.flags,s.flags);const c=Object.assign({},a.terms);if(s.terms)for(const v in s.terms){const u=s.terms[v];l(void 0===o.$_terms[v],"Invalid term override for",s.type,v),o.$_terms[v]=u.init,c[v]=u}s.terms=c,s.args||(s.args=a.args),s.prepare=e.prepare(s.prepare,a.prepare),s.coerce&&("function"==typeof s.coerce&&(s.coerce={method:s.coerce}),s.coerce.from&&!Array.isArray(s.coerce.from)&&(s.coerce={method:s.coerce.method,from:[].concat(s.coerce.from)})),s.coerce=e.coerce(s.coerce,a.coerce),s.validate=e.validate(s.validate,a.validate);const h=Object.assign({},a.rules);if(s.rules)for(const v in s.rules){const u=s.rules[v];l("object"==typeof u,"Invalid rule definition for",s.type,v);let m=u.method;if(void 0===m&&(m=function(){return this.$_addRule(v)}),m&&(l(!t[v],"Rule conflict in",s.type,v),t[v]=m),l(!h[v],"Rule conflict in",s.type,v),h[v]=u,u.alias){const g=[].concat(u.alias);for(const w of g)t[w]=u.method}u.args&&(u.argsByName=new Map,u.args=u.args.map(g=>("string"==typeof g&&(g={name:g}),l(!u.argsByName.has(g.name),"Duplicated argument name",g.name),d.isSchema(g.assert)&&(g.assert=g.assert.strict().label(g.name)),u.argsByName.set(g.name,g),g)))}s.rules=h;const p=Object.assign({},a.modifiers);if(s.modifiers)for(const v in s.modifiers){l(!t[v],"Rule conflict in",s.type,v);const u=s.modifiers[v];l("function"==typeof u,"Invalid modifier definition for",s.type,v),t[v]=function(g){return this.rule({[v]:g})},p[v]=u}if(s.modifiers=p,s.overrides){t._super=r,o.$_super={};for(const v in s.overrides)l(r[v],"Cannot override missing",v),s.overrides[v][d.symbols.parent]=r[v],o.$_super[v]=r[v].bind(o);Object.assign(t,s.overrides)}s.cast=Object.assign({},a.cast,s.cast);const _=Object.assign({},a.manifest,s.manifest);return _.build=e.build(s.manifest&&s.manifest.build,a.manifest&&a.manifest.build),s.manifest=_,s.rebuild=e.rebuild(s.rebuild,a.rebuild),o},e.build=function(i,n){return i&&n?function(r,t){return n(i(r,t),t)}:i||n},e.coerce=function(i,n){return i&&n?{from:i.from&&n.from?[...new Set([...i.from,...n.from])]:null,method(r,t){let o;if((!n.from||n.from.includes(typeof r))&&(o=n.method(r,t),o)){if(o.errors||void 0===o.value)return o;r=o.value}if(!i.from||i.from.includes(typeof r)){const s=i.method(r,t);if(s)return s}return o}}:i||n},e.prepare=function(i,n){return i&&n?function(r,t){const o=i(r,t);if(o){if(o.errors||void 0===o.value)return o;r=o.value}return n(r,t)||o}:i||n},e.rebuild=function(i,n){return i&&n?function(r){n(r),i(r)}:i||n},e.validate=function(i,n){return i&&n?function(r,t){const o=n(r,t);if(o){if(o.errors&&(!Array.isArray(o.errors)||o.errors.length))return o;r=o.value}return i(r,t)||o}:i||n}},5107:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(8652),f=b(8160),e=b(3292),i=b(6354),n=b(8901),r=b(9708),t=b(6133),o=b(3328),s=b(1152);let a;const c={types:{alternatives:b(4946),any:b(8068),array:b(546),boolean:b(4937),date:b(7500),function:b(390),link:b(8785),number:b(3832),object:b(8966),string:b(7417),symbol:b(8826)},aliases:{alt:"alternatives",bool:"boolean",func:"function"},root:function(){const h={_types:new Set(Object.keys(c.types))};for(const p of h._types)h[p]=function(..._){return l(!_.length||["alternatives","link","object"].includes(p),"The",p,"type does not allow arguments"),c.generate(this,c.types[p],_)};for(const p of["allow","custom","disallow","equal","exist","forbidden","invalid","not","only","optional","options","prefs","preferences","required","strip","valid","when"])h[p]=function(..._){return this.any()[p](..._)};Object.assign(h,c.methods);for(const p in c.aliases)h[p]=h[c.aliases[p]];return h.x=h.expression,s.setup&&s.setup(h),h}};c.methods={ValidationError:i.ValidationError,version:f.version,cache:d.provider,assert(h,p,..._){c.assert(h,p,!0,_)},attempt:(h,p,..._)=>c.assert(h,p,!1,_),build(h){return l("function"==typeof r.build,"Manifest functionality disabled"),r.build(this,h)},checkPreferences(h){f.checkPreferences(h)},compile(h,p){return e.compile(this,h,p)},defaults(h){l("function"==typeof h,"modifier must be a function");const p=Object.assign({},this);for(const _ of p._types){const v=h(p[_]());l(f.isSchema(v),"modifier must return a valid schema object"),p[_]=function(...u){return c.generate(this,v,u)}}return p},expression:(...h)=>new o(...h),extend(...h){f.verifyFlat(h,"extend"),a=a||b(3378),l(h.length,"You need to provide at least one extension"),this.assert(h,a.extensions);const p=Object.assign({},this);p._types=new Set(p._types);for(let _ of h){"function"==typeof _&&(_=_(p)),this.assert(_,a.extension);const v=c.expandExtension(_,p);for(const u of v){l(void 0===p[u.type]||p._types.has(u.type),"Cannot override name",u.type);const m=u.base||this.any(),g=n.type(m,u);p._types.add(u.type),p[u.type]=function(...w){return c.generate(this,g,w)}}}return p},isError:i.ValidationError.isError,isExpression:o.isTemplate,isRef:t.isRef,isSchema:f.isSchema,in:(...h)=>t.in(...h),override:f.symbols.override,ref:(...h)=>t.create(...h),types(){const h={};for(const p of this._types)h[p]=this[p]();for(const p in c.aliases)h[p]=this[p]();return h}},c.assert=function(h,p,_,v){const u=v[0]instanceof Error||"string"==typeof v[0]?v[0]:null,g=p.validate(h,f.preferences({errors:{stack:!0}},(null!==u?v[1]:v[0])||{}));let w=g.error;if(!w)return g.value;if(u instanceof Error)throw u;const x=_&&"function"==typeof w.annotate?w.annotate():w.message;throw w instanceof i.ValidationError==0&&(w=y(w)),w.message=u?`${u} ${x}`:x,w},c.generate=function(h,p,_){return l(h,"Must be invoked on a Joi instance."),p.$_root=h,p._definition.args&&_.length?p._definition.args(p,..._):p},c.expandExtension=function(h,p){if("string"==typeof h.type)return[h];const _=[];for(const v of p._types)if(h.type.test(v)){const u=Object.assign({},h);u.type=v,u.base=p[v](),_.push(u)}return _},j.exports=c.root()},6914:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(3328);$.compile=function(f,e){if("string"==typeof f)return l(!e,"Cannot set single message string"),new d(f);if(d.isTemplate(f))return l(!e,"Cannot set single message template"),f;l("object"==typeof f&&!Array.isArray(f),"Invalid message options"),e=e?y(e):{};for(let i in f){const n=f[i];if("root"===i||d.isTemplate(n)){e[i]=n;continue}if("string"==typeof n){e[i]=new d(n);continue}l("object"==typeof n&&!Array.isArray(n),"Invalid message for",i);const r=i;for(i in e[r]=e[r]||{},n){const t=n[i];"root"===i||d.isTemplate(t)?e[r][i]=t:(l("string"==typeof t,"Invalid message for",i,"in",r),e[r][i]=new d(t))}}return e},$.decompile=function(f){const e={};for(let i in f){const n=f[i];if("root"===i){e.root=n;continue}if(d.isTemplate(n)){e[i]=n.describe({compact:!0});continue}const r=i;for(i in e[r]={},n){const t=n[i];"root"!==i?e[r][i]=t.describe({compact:!0}):e[r].root=t}}return e},$.merge=function(f,e){if(!f)return $.compile(e);if(!e)return f;if("string"==typeof e)return new d(e);if(d.isTemplate(e))return e;const i=y(f);for(let n in e){const r=e[n];if("root"===n||d.isTemplate(r)){i[n]=r;continue}if("string"==typeof r){i[n]=new d(r);continue}l("object"==typeof r&&!Array.isArray(r),"Invalid message for",n);const t=n;for(n in i[t]=i[t]||{},r){const o=r[n];"root"===n||d.isTemplate(o)?i[t][n]=o:(l("string"==typeof o,"Invalid message for",n,"in",t),i[t][n]=new d(o))}}return i}},2294:(j,$,b)=>{"use strict";const l=b(375),y=b(8160),d=b(6133),f={};$.Ids=f.Ids=class{constructor(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}clone(){const e=new f.Ids;return e._byId=new Map(this._byId),e._byKey=new Map(this._byKey),e._schemaChain=this._schemaChain,e}concat(e){e._schemaChain&&(this._schemaChain=!0);for(const[i,n]of e._byId.entries())l(!this._byKey.has(i),"Schema id conflicts with existing key:",i),this._byId.set(i,n);for(const[i,n]of e._byKey.entries())l(!this._byId.has(i),"Schema key conflicts with existing id:",i),this._byKey.set(i,n)}fork(e,i,n){const r=this._collect(e);r.push({schema:n});const t=r.shift();let o={id:t.id,schema:i(t.schema)};l(y.isSchema(o.schema),"adjuster function failed to return a joi schema type");for(const s of r)o={id:s.id,schema:f.fork(s.schema,o.id,o.schema)};return o.schema}labels(e,i=[]){const n=e[0],r=this._get(n);if(!r)return[...i,...e].join(".");const t=e.slice(1);return i=[...i,r.schema._flags.label||n],t.length?r.schema._ids.labels(t,i):i.join(".")}reach(e,i=[]){const n=e[0],r=this._get(n);l(r,"Schema does not contain path",[...i,...e].join("."));const t=e.slice(1);return t.length?r.schema._ids.reach(t,[...i,n]):r.schema}register(e,{key:i}={}){if(!e||!y.isSchema(e))return;(e.$_property("schemaChain")||e._ids._schemaChain)&&(this._schemaChain=!0);const n=e._flags.id;if(n){const r=this._byId.get(n);l(!r||r.schema===e,"Cannot add different schemas with the same id:",n),l(!this._byKey.has(n),"Schema id conflicts with existing key:",n),this._byId.set(n,{schema:e,id:n})}i&&(l(!this._byKey.has(i),"Schema already contains key:",i),l(!this._byId.has(i),"Schema key conflicts with existing id:",i),this._byKey.set(i,{schema:e,id:i}))}reset(){this._byId=new Map,this._byKey=new Map,this._schemaChain=!1}_collect(e,i=[],n=[]){const r=e[0],t=this._get(r);l(t,"Schema does not contain path",[...i,...e].join(".")),n=[t,...n];const o=e.slice(1);return o.length?t.schema._ids._collect(o,[...i,r],n):n}_get(e){return this._byId.get(e)||this._byKey.get(e)}},f.fork=function(e,i,n){const r=$.schema(e,{each:(t,{key:o})=>{if(i===(t._flags.id||o))return n},ref:!1});return r?r.$_mutateRebuild():e},$.schema=function(e,i){let n;for(const r in e._flags){if("_"===r[0])continue;const t=f.scan(e._flags[r],{source:"flags",name:r},i);void 0!==t&&(n=n||e.clone(),n._flags[r]=t)}for(let r=0;r<e._rules.length;++r){const t=e._rules[r],o=f.scan(t.args,{source:"rules",name:t.name},i);if(void 0!==o){n=n||e.clone();const s=Object.assign({},t);s.args=o,n._rules[r]=s,n._singleRules.get(t.name)===t&&n._singleRules.set(t.name,s)}}for(const r in e.$_terms){if("_"===r[0])continue;const t=f.scan(e.$_terms[r],{source:"terms",name:r},i);void 0!==t&&(n=n||e.clone(),n.$_terms[r]=t)}return n},f.scan=function(e,i,n,r,t){const o=r||[];if(null===e||"object"!=typeof e)return;let s;if(Array.isArray(e)){for(let a=0;a<e.length;++a){const c="terms"===i.source&&"keys"===i.name&&e[a].key,h=f.scan(e[a],i,n,[a,...o],c);void 0!==h&&(s=s||e.slice(),s[a]=h)}return s}if(!1!==n.schema&&y.isSchema(e)||!1!==n.ref&&d.isRef(e)){const a=n.each(e,{...i,path:o,key:t});return a===e?void 0:a}for(const a in e){if("_"===a[0])continue;const c=f.scan(e[a],i,n,[a,...o],t);void 0!==c&&(s=s||Object.assign({},e),s[a]=c)}return s}},6133:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(9621),f=b(8160);let e;const i={symbol:Symbol("ref"),defaults:{adjust:null,in:!1,iterables:null,map:null,separator:".",type:"value"}};$.create=function(n,r={}){l("string"==typeof n,"Invalid reference key:",n),f.assertOptions(r,["adjust","ancestor","in","iterables","map","prefix","render","separator"]),l(!r.prefix||"object"==typeof r.prefix,"options.prefix must be of type object");const t=Object.assign({},i.defaults,r);delete t.prefix;const o=t.separator,s=i.context(n,o,r.prefix);if(t.type=s.type,n=s.key,"value"===t.type)if(s.root&&(l(!o||n[0]!==o,"Cannot specify relative path with root prefix"),t.ancestor="root",n||(n=null)),o&&o===n)n=null,t.ancestor=0;else if(void 0!==t.ancestor)l(!o||!n||n[0]!==o,"Cannot combine prefix with ancestor option");else{const[a,c]=i.ancestor(n,o);c&&""===(n=n.slice(c))&&(n=null),t.ancestor=a}return t.path=o?null===n?[]:n.split(o):[n],new i.Ref(t)},$.in=function(n,r={}){return $.create(n,{...r,in:!0})},$.isRef=function(n){return!!n&&!!n[f.symbols.ref]},i.Ref=class{constructor(n){l("object"==typeof n,"Invalid reference construction"),f.assertOptions(n,["adjust","ancestor","in","iterables","map","path","render","separator","type","depth","key","root","display"]),l([!1,void 0].includes(n.separator)||"string"==typeof n.separator&&1===n.separator.length,"Invalid separator"),l(!n.adjust||"function"==typeof n.adjust,"options.adjust must be a function"),l(!n.map||Array.isArray(n.map),"options.map must be an array"),l(!n.map||!n.adjust,"Cannot set both map and adjust options"),Object.assign(this,i.defaults,n),l("value"===this.type||void 0===this.ancestor,"Non-value references cannot reference ancestors"),Array.isArray(this.map)&&(this.map=new Map(this.map)),this.depth=this.path.length,this.key=this.path.length?this.path.join(this.separator):null,this.root=this.path[0],this.updateDisplay()}resolve(n,r,t,o,s={}){return l(!this.in||s.in,"Invalid in() reference usage"),"global"===this.type?this._resolve(t.context,r,s):"local"===this.type?this._resolve(o,r,s):this.ancestor?"root"===this.ancestor?this._resolve(r.ancestors[r.ancestors.length-1],r,s):(l(this.ancestor<=r.ancestors.length,"Invalid reference exceeds the schema root:",this.display),this._resolve(r.ancestors[this.ancestor-1],r,s)):this._resolve(n,r,s)}_resolve(n,r,t){let o;if("value"===this.type&&r.mainstay.shadow&&!1!==t.shadow&&(o=r.mainstay.shadow.get(this.absolute(r))),void 0===o&&(o=d(n,this.path,{iterables:this.iterables,functions:!0})),this.adjust&&(o=this.adjust(o)),this.map){const s=this.map.get(o);void 0!==s&&(o=s)}return r.mainstay&&r.mainstay.tracer.resolve(r,this,o),o}toString(){return this.display}absolute(n){return[...n.path.slice(0,-this.ancestor),...this.path]}clone(){return new i.Ref(this)}describe(){const n={path:this.path};"value"!==this.type&&(n.type=this.type),"."!==this.separator&&(n.separator=this.separator),"value"===this.type&&1!==this.ancestor&&(n.ancestor=this.ancestor),this.map&&(n.map=[...this.map]);for(const r of["adjust","iterables","render"])null!=this[r]&&(n[r]=this[r]);return!1!==this.in&&(n.in=!0),{ref:n}}updateDisplay(){const n=null!==this.key?this.key:"";if("value"!==this.type)return void(this.display=`ref:${this.type}:${n}`);if(!this.separator)return void(this.display=`ref:${n}`);if(!this.ancestor)return void(this.display=`ref:${this.separator}${n}`);if("root"===this.ancestor)return void(this.display=`ref:root:${n}`);if(1===this.ancestor)return void(this.display=`ref:${n||".."}`);const r=new Array(this.ancestor+1).fill(this.separator).join("");this.display=`ref:${r}${n||""}`}},i.Ref.prototype[f.symbols.ref]=!0,$.build=function(n){return"value"===(n=Object.assign({},i.defaults,n)).type&&void 0===n.ancestor&&(n.ancestor=1),new i.Ref(n)},i.context=function(n,r,t={}){if(n=n.trim(),t){const o=void 0===t.global?"$":t.global;if(o!==r&&n.startsWith(o))return{key:n.slice(o.length),type:"global"};const s=void 0===t.local?"#":t.local;if(s!==r&&n.startsWith(s))return{key:n.slice(s.length),type:"local"};const a=void 0===t.root?"/":t.root;if(a!==r&&n.startsWith(a))return{key:n.slice(a.length),type:"value",root:!0}}return{key:n,type:"value"}},i.ancestor=function(n,r){if(!r)return[1,0];if(n[0]!==r)return[1,0];if(n[1]!==r)return[0,1];let t=2;for(;n[t]===r;)++t;return[t-1,t]},$.toSibling=0,$.toParent=1,$.Manager=class{constructor(){this.refs=[]}register(n,r){if(n)if(r=void 0===r?$.toParent:r,Array.isArray(n))for(const t of n)this.register(t,r);else if(f.isSchema(n))for(const t of n._refs.refs)t.ancestor-r>=0&&this.refs.push({ancestor:t.ancestor-r,root:t.root});else $.isRef(n)&&"value"===n.type&&n.ancestor-r>=0&&this.refs.push({ancestor:n.ancestor-r,root:n.root}),e=e||b(3328),e.isTemplate(n)&&this.register(n.refs(),r)}get length(){return this.refs.length}clone(){const n=new $.Manager;return n.refs=y(this.refs),n}reset(){this.refs=[]}roots(){return this.refs.filter(n=>!n.ancestor).map(n=>n.root)}}},3378:(j,$,b)=>{"use strict";const l=b(5107),y={};y.wrap=l.string().min(1).max(2).allow(!1),$.preferences=l.object({allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),context:l.object(),convert:l.boolean(),dateFormat:l.valid("date","iso","string","time","utc"),debug:l.boolean(),errors:{escapeHtml:l.boolean(),label:l.valid("path","key",!1),language:[l.string(),l.object().ref()],render:l.boolean(),stack:l.boolean(),wrap:{label:y.wrap,array:y.wrap,string:y.wrap}},externals:l.boolean(),messages:l.object(),noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:l.valid("required","optional","forbidden"),skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()}).strict(),y.nameRx=/^[a-zA-Z0-9]\w*$/,y.rule=l.object({alias:l.array().items(l.string().pattern(y.nameRx)).single(),args:l.array().items(l.string(),l.object({name:l.string().pattern(y.nameRx).required(),ref:l.boolean(),assert:l.alternatives([l.function(),l.object().schema()]).conditional("ref",{is:!0,then:l.required()}),normalize:l.function(),message:l.string().when("assert",{is:l.function(),then:l.required()})})),convert:l.boolean(),manifest:l.boolean(),method:l.function().allow(!1),multi:l.boolean(),validate:l.function()}),$.extension=l.object({type:l.alternatives([l.string(),l.object().regex()]).required(),args:l.function(),cast:l.object().pattern(y.nameRx,l.object({from:l.function().maxArity(1).required(),to:l.function().minArity(1).maxArity(2).required()})),base:l.object().schema().when("type",{is:l.object().regex(),then:l.forbidden()}),coerce:[l.function().maxArity(3),l.object({method:l.function().maxArity(3).required(),from:l.array().items(l.string()).single()})],flags:l.object().pattern(y.nameRx,l.object({setter:l.string(),default:l.any()})),manifest:{build:l.function().arity(2)},messages:[l.object(),l.string()],modifiers:l.object().pattern(y.nameRx,l.function().minArity(1).maxArity(2)),overrides:l.object().pattern(y.nameRx,l.function()),prepare:l.function().maxArity(3),rebuild:l.function().arity(1),rules:l.object().pattern(y.nameRx,y.rule),terms:l.object().pattern(y.nameRx,l.object({init:l.array().allow(null).required(),manifest:l.object().pattern(/.+/,[l.valid("schema","single"),l.object({mapped:l.object({from:l.string().required(),to:l.string().required()}).required()})])})),validate:l.function().maxArity(3)}).strict(),$.extensions=l.array().items(l.object(),l.function().arity(1)).strict(),y.desc={buffer:l.object({buffer:l.string()}),func:l.object({function:l.function().required(),options:{literal:!0}}),override:l.object({override:!0}),ref:l.object({ref:l.object({type:l.valid("value","global","local"),path:l.array().required(),separator:l.string().length(1).allow(!1),ancestor:l.number().min(0).integer().allow("root"),map:l.array().items(l.array().length(2)).min(1),adjust:l.function(),iterables:l.boolean(),in:l.boolean(),render:l.boolean()}).required()}),regex:l.object({regex:l.string().min(3)}),special:l.object({special:l.valid("deep").required()}),template:l.object({template:l.string().required(),options:l.object()}),value:l.object({value:l.alternatives([l.object(),l.array()]).required()})},y.desc.entity=l.alternatives([l.array().items(l.link("...")),l.boolean(),l.function(),l.number(),l.string(),y.desc.buffer,y.desc.func,y.desc.ref,y.desc.regex,y.desc.special,y.desc.template,y.desc.value,l.link("/")]),y.desc.values=l.array().items(null,l.boolean(),l.function(),l.number().allow(1/0,-1/0),l.string().allow(""),l.symbol(),y.desc.buffer,y.desc.func,y.desc.override,y.desc.ref,y.desc.regex,y.desc.template,y.desc.value),y.desc.messages=l.object().pattern(/.+/,[l.string(),y.desc.template,l.object().pattern(/.+/,[l.string(),y.desc.template])]),$.description=l.object({type:l.string().required(),flags:l.object({cast:l.string(),default:l.any(),description:l.string(),empty:l.link("/"),failover:y.desc.entity,id:l.string(),label:l.string(),only:!0,presence:["optional","required","forbidden"],result:["raw","strip"],strip:l.boolean(),unit:l.string()}).unknown(),preferences:{allowUnknown:l.boolean(),abortEarly:l.boolean(),artifacts:l.boolean(),cache:l.boolean(),convert:l.boolean(),dateFormat:["date","iso","string","time","utc"],errors:{escapeHtml:l.boolean(),label:["path","key"],language:[l.string(),y.desc.ref],wrap:{label:y.wrap,array:y.wrap}},externals:l.boolean(),messages:y.desc.messages,noDefaults:l.boolean(),nonEnumerables:l.boolean(),presence:["required","optional","forbidden"],skipFunctions:l.boolean(),stripUnknown:l.object({arrays:l.boolean(),objects:l.boolean()}).or("arrays","objects").allow(!0,!1),warnings:l.boolean()},allow:y.desc.values,invalid:y.desc.values,rules:l.array().min(1).items({name:l.string().required(),args:l.object().min(1),keep:l.boolean(),message:[l.string(),y.desc.messages],warn:l.boolean()}),keys:l.object().pattern(/.*/,l.link("/")),link:y.desc.ref}).pattern(/^[a-z]\w*$/,l.any())},493:(j,$,b)=>{"use strict";const l=b(8571),y=b(9621),d=b(8160),f={value:Symbol("value")};j.exports=f.State=class{constructor(e,i,n){this.path=e,this.ancestors=i,this.mainstay=n.mainstay,this.schemas=n.schemas,this.debug=null}localize(e,i=null,n=null){const r=new f.State(e,i,this);return n&&r.schemas&&(r.schemas=[f.schemas(n),...r.schemas]),r}nest(e,i){const n=new f.State(this.path,this.ancestors,this);return n.schemas=n.schemas&&[f.schemas(e),...n.schemas],n.debug=i,n}shadow(e,i){this.mainstay.shadow=this.mainstay.shadow||new f.Shadow,this.mainstay.shadow.set(this.path,e,i)}snapshot(){this.mainstay.shadow&&(this._snapshot=l(this.mainstay.shadow.node(this.path))),this.mainstay.snapshot()}restore(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.restore()}commit(){this.mainstay.shadow&&(this.mainstay.shadow.override(this.path,this._snapshot),this._snapshot=void 0),this.mainstay.commit()}},f.schemas=function(e){return d.isSchema(e)?{schema:e}:e},f.Shadow=class{constructor(){this._values=null}set(e,i,n){if(!e.length||"strip"===n&&"number"==typeof e[e.length-1])return;this._values=this._values||new Map;let r=this._values;for(let t=0;t<e.length;++t){const o=e[t];let s=r.get(o);s||(s=new Map,r.set(o,s)),r=s}r[f.value]=i}get(e){const i=this.node(e);if(i)return i[f.value]}node(e){if(this._values)return y(this._values,e,{iterables:!0})}override(e,i){if(!this._values)return;const n=e.slice(0,-1),r=e[e.length-1],t=y(this._values,n,{iterables:!0});i?t.set(r,i):t&&t.delete(r)}}},3328:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(5277),f=b(1447),e=b(8160),i=b(6354),n=b(6133),r={symbol:Symbol("template"),opens:new Array(1e3).join("\0"),closes:new Array(1e3).join("\x01"),dateFormat:{date:Date.prototype.toDateString,iso:Date.prototype.toISOString,string:Date.prototype.toString,time:Date.prototype.toTimeString,utc:Date.prototype.toUTCString}};j.exports=r.Template=class{constructor(t,o){if(l("string"==typeof t,"Template source must be a string"),l(!t.includes("\0")&&!t.includes("\x01"),"Template source cannot contain reserved control characters"),this.source=t,this.rendered=t,this._template=null,o){const{functions:s,...a}=o;this._settings=Object.keys(a).length?y(a):void 0,this._functions=s,this._functions&&(l(Object.keys(this._functions).every(c=>"string"==typeof c),"Functions keys must be strings"),l(Object.values(this._functions).every(c=>"function"==typeof c),"Functions values must be functions"))}else this._settings=void 0,this._functions=void 0;this._parse()}_parse(){if(!this.source.includes("{"))return;const t=r.encode(this.source),o=r.split(t);let s=!1;const a=[],c=o.shift();c&&a.push(c);for(const h of o){const p="{"!==h[0],_=p?"}":"}}",v=h.indexOf(_);if(-1===v||"{"===h[1]){a.push(`{${r.decode(h)}`);continue}let u=h.slice(p?0:1,v);const m=":"===u[0];m&&(u=u.slice(1));const g=this._ref(r.decode(u),{raw:p,wrapped:m});a.push(g),"string"!=typeof g&&(s=!0);const w=h.slice(v+_.length);w&&a.push(r.decode(w))}s?this._template=a:this.rendered=a.join("")}static date(t,o){return r.dateFormat[o.dateFormat].call(t)}describe(t={}){if(!this._settings&&t.compact)return this.source;const o={template:this.source};return this._settings&&(o.options=this._settings),this._functions&&(o.functions=this._functions),o}static build(t){return new r.Template(t.template,t.options||t.functions?{...t.options,functions:t.functions}:void 0)}isDynamic(){return!!this._template}static isTemplate(t){return!!t&&!!t[e.symbols.template]}refs(){if(!this._template)return;const t=[];for(const o of this._template)"string"!=typeof o&&t.push(...o.refs);return t}resolve(t,o,s,a){return this._template&&1===this._template.length?this._part(this._template[0],t,o,s,a,{}):this.render(t,o,s,a)}_part(t,...o){return t.ref?t.ref.resolve(...o):t.formula.evaluate(o)}render(t,o,s,a,c={}){if(!this.isDynamic())return this.rendered;const h=[];for(const p of this._template)if("string"==typeof p)h.push(p);else{const _=this._part(p,t,o,s,a,c),v=r.stringify(_,t,o,s,a,c);if(void 0!==v){const u=p.raw||!1===(c.errors&&c.errors.escapeHtml)?v:d(v);h.push(r.wrap(u,p.wrapped&&s.errors.wrap.label))}}return h.join("")}_ref(t,{raw:o,wrapped:s}){const a=[],c=p=>{const _=n.create(p,this._settings);return a.push(_),v=>{const u=_.resolve(...v);return void 0!==u?u:null}};try{const p=this._functions?{...r.functions,...this._functions}:r.functions;var h=new f.Parser(t,{reference:c,functions:p,constants:r.constants})}catch(p){throw p.message=`Invalid template variable "${t}" fails due to: ${p.message}`,p}if(h.single){if("reference"===h.single.type){const p=a[0];return{ref:p,raw:o,refs:a,wrapped:s||"local"===p.type&&"label"===p.key}}return r.stringify(h.single.value)}return{formula:h,raw:o,refs:a}}toString(){return this.source}},r.Template.prototype[e.symbols.template]=!0,r.Template.prototype.isImmutable=!0,r.encode=function(t){return t.replace(/\\(\{+)/g,(o,s)=>r.opens.slice(0,s.length)).replace(/\\(\}+)/g,(o,s)=>r.closes.slice(0,s.length))},r.decode=function(t){return t.replace(/\u0000/g,"{").replace(/\u0001/g,"}")},r.split=function(t){const o=[];let s="";for(let a=0;a<t.length;++a){const c=t[a];if("{"===c){let h="";for(;a+1<t.length&&"{"===t[a+1];)h+="{",++a;o.push(s),s=h}else s+=c}return o.push(s),o},r.wrap=function(t,o){return o?1===o.length?`${o}${t}${o}`:`${o[0]}${t}${o[1]}`:t},r.stringify=function(t,o,s,a,c,h={}){const p=typeof t,_=a&&a.errors&&a.errors.wrap||{};let v=!1;if(n.isRef(t)&&t.render&&(v=t.in,t=t.resolve(o,s,a,c,{in:t.in,...h})),null===t)return"null";if("string"===p)return r.wrap(t,h.arrayItems&&_.string);if("number"===p||"function"===p||"symbol"===p)return t.toString();if("object"!==p)return JSON.stringify(t);if(t instanceof Date)return r.Template.date(t,a);if(t instanceof Map){const m=[];for(const[g,w]of t.entries())m.push(`${g.toString()} -> ${w.toString()}`);t=m}if(!Array.isArray(t))return t.toString();const u=[];for(const m of t)u.push(r.stringify(m,o,s,a,c,{arrayItems:!0,...h}));return r.wrap(u.join(", "),!v&&_.array)},r.constants={true:!0,false:!1,null:null,second:1e3,minute:6e4,hour:36e5,day:864e5},r.functions={if:(t,o,s)=>t?o:s,length:t=>"string"==typeof t?t.length:t&&"object"==typeof t?Array.isArray(t)?t.length:Object.keys(t).length:null,msg(t){const[o,s,a,c,h]=this,p=h.messages;if(!p)return"";const _=i.template(o,p[0],t,s,a)||i.template(o,p[1],t,s,a);return _?_.render(o,s,a,c,h):""},number:t=>"number"==typeof t?t:"string"==typeof t?parseFloat(t):"boolean"==typeof t?t?1:0:t instanceof Date?t.getTime():null}},4946:(j,$,b)=>{"use strict";const l=b(375),y=b(1687),d=b(8068),f=b(8160),e=b(3292),i=b(6354),n=b(6133),r={};j.exports=d.extend({type:"alternatives",flags:{match:{default:"any"}},terms:{matches:{init:[],register:n.toSibling}},args:(t,...o)=>1===o.length&&Array.isArray(o[0])?t.try(...o[0]):t.try(...o),validate(t,o){const{schema:s,error:a,state:c,prefs:h}=o;if(s._flags.match){const _=[],v=[];for(let m=0;m<s.$_terms.matches.length;++m){const g=s.$_terms.matches[m],w=c.nest(g.schema,`match.${m}`);w.snapshot();const x=g.schema.$_validate(t,w,h);x.errors?(v.push(x.errors),w.restore()):(_.push(x.value),w.commit())}if(0===_.length)return{errors:a("alternatives.any",{details:v.map(m=>i.details(m,{override:!1}))})};if("one"===s._flags.match)return 1===_.length?{value:_[0]}:{errors:a("alternatives.one")};if(_.length!==s.$_terms.matches.length)return{errors:a("alternatives.all",{details:v.map(m=>i.details(m,{override:!1}))})};const u=m=>m.$_terms.matches.some(g=>"object"===g.schema.type||"alternatives"===g.schema.type&&u(g.schema));return u(s)?{value:_.reduce((m,g)=>y(m,g,{mergeArrays:!1}))}:{value:_[_.length-1]}}const p=[];for(let _=0;_<s.$_terms.matches.length;++_){const v=s.$_terms.matches[_];if(v.schema){const g=c.nest(v.schema,`match.${_}`);g.snapshot();const w=v.schema.$_validate(t,g,h);if(!w.errors)return g.commit(),w;g.restore(),p.push({schema:v.schema,reports:w.errors});continue}const u=v.ref?v.ref.resolve(t,c,h):t,m=v.is?[v]:v.switch;for(let g=0;g<m.length;++g){const w=m[g],{is:x,then:k,otherwise:R}=w,S=`match.${_}${v.switch?"."+g:""}`;if(x.$_match(u,c.nest(x,`${S}.is`),h)){if(k)return k.$_validate(t,c.nest(k,`${S}.then`),h)}else if(R)return R.$_validate(t,c.nest(R,`${S}.otherwise`),h)}}return r.errors(p,o)},rules:{conditional:{method(t,o){l(!this._flags._endedSwitch,"Unreachable condition"),l(!this._flags.match,"Cannot combine match mode",this._flags.match,"with conditional rule"),l(void 0===o.break,"Cannot use break option with alternatives conditional");const s=this.clone(),a=e.when(s,t,o),c=a.is?[a]:a.switch;for(const h of c)if(h.then&&h.otherwise){s.$_setFlag("_endedSwitch",!0,{clone:!1});break}return s.$_terms.matches.push(a),s.$_mutateRebuild()}},match:{method(t){if(l(["any","one","all"].includes(t),"Invalid alternatives match mode",t),"any"!==t)for(const o of this.$_terms.matches)l(o.schema,"Cannot combine match mode",t,"with conditional rules");return this.$_setFlag("match",t)}},try:{method(...t){l(t.length,"Missing alternative schemas"),f.verifyFlat(t,"try"),l(!this._flags._endedSwitch,"Unreachable condition");const o=this.clone();for(const s of t)o.$_terms.matches.push({schema:o.$_compile(s)});return o.$_mutateRebuild()}}},overrides:{label(t){return this.$_parent("label",t).$_modify({each:(o,s)=>"is"!==s.path[0]&&"string"!=typeof o._flags.label?o.label(t):void 0,ref:!1})}},rebuild(t){t.$_modify({each:o=>{f.isSchema(o)&&"array"===o.type&&t.$_setFlag("_arrayItems",!0,{clone:!1})}})},manifest:{build(t,o){if(o.matches)for(const s of o.matches){const{schema:a,ref:c,is:h,not:p,then:_,otherwise:v}=s;t=a?t.try(a):c?t.conditional(c,{is:h,then:_,not:p,otherwise:v,switch:s.switch}):t.conditional(h,{then:_,otherwise:v})}return t}},messages:{"alternatives.all":"{{#label}} does not match all of the required types","alternatives.any":"{{#label}} does not match any of the allowed types","alternatives.match":"{{#label}} does not match any of the allowed types","alternatives.one":"{{#label}} matches more than one allowed type","alternatives.types":"{{#label}} must be one of {{#types}}"}}),r.errors=function(t,{error:o,state:s}){if(!t.length)return{errors:o("alternatives.any")};if(1===t.length)return{errors:t[0].reports};const a=new Set,c=[];for(const{reports:h,schema:p}of t){if(h.length>1)return r.unmatched(t,o);const _=h[0];if(_ instanceof i.Report==0)return r.unmatched(t,o);if(_.state.path.length!==s.path.length){c.push({type:p.type,report:_});continue}if("any.only"===_.code){for(const m of _.local.valids)a.add(m);continue}const[v,u]=_.code.split(".");"base"===u?a.add(v):c.push({type:p.type,report:_})}return c.length?1===c.length?{errors:c[0].report}:r.unmatched(t,o):{errors:o("alternatives.types",{types:[...a]})}},r.unmatched=function(t,o){const s=[];for(const a of t)s.push(...a.reports);return{errors:o("alternatives.match",i.details(s,{override:!1}))}}},8068:(j,$,b)=>{"use strict";const l=b(375),y=b(7629),d=b(8160),f=b(6914);j.exports=y.extend({type:"any",flags:{only:{default:!1}},terms:{alterations:{init:null},examples:{init:null},externals:{init:null},metas:{init:[]},notes:{init:[]},shared:{init:null},tags:{init:[]},whens:{init:null}},rules:{custom:{method(e,i){return l("function"==typeof e,"Method must be a function"),l(void 0===i||i&&"string"==typeof i,"Description must be a non-empty string"),this.$_addRule({name:"custom",args:{method:e,description:i}})},validate(e,i,{method:n}){try{return n(e,i)}catch(r){return i.error("any.custom",{error:r})}},args:["method","description"],multi:!0},messages:{method(e){return this.prefs({messages:e})}},shared:{method(e){l(d.isSchema(e)&&e._flags.id,"Schema must be a schema with an id");const i=this.clone();return i.$_terms.shared=i.$_terms.shared||[],i.$_terms.shared.push(e),i.$_mutateRegister(e),i}},warning:{method(e,i){return l(e&&"string"==typeof e,"Invalid warning code"),this.$_addRule({name:"warning",args:{code:e,local:i},warn:!0})},validate:(e,i,{code:n,local:r})=>i.error(n,r),args:["code","local"],multi:!0}},modifiers:{keep(e,i=!0){e.keep=i},message(e,i){e.message=f.compile(i)},warn(e,i=!0){e.warn=i}},manifest:{build(e,i){for(const n in i){const r=i[n];if(["examples","externals","metas","notes","tags"].includes(n))for(const t of r)e=e[n.slice(0,-1)](t);else if("alterations"!==n)if("whens"!==n){if("shared"===n)for(const t of r)e=e.shared(t)}else for(const t of r){const{ref:o,is:s,not:a,then:c,otherwise:h,concat:p}=t;e=p?e.concat(p):o?e.when(o,{is:s,not:a,then:c,otherwise:h,switch:t.switch,break:t.break}):e.when(s,{then:c,otherwise:h,break:t.break})}else{const t={};for(const{target:o,adjuster:s}of r)t[o]=s;e=e.alter(t)}}return e}},messages:{"any.custom":"{{#label}} failed custom validation because {{#error.message}}","any.default":"{{#label}} threw an error when running default method","any.failover":"{{#label}} threw an error when running failover method","any.invalid":"{{#label}} contains an invalid value","any.only":'{{#label}} must be {if(#valids.length == 1, "", "one of ")}{{#valids}}',"any.ref":"{{#label}} {{#arg}} references {{:#ref}} which {{#reason}}","any.required":"{{#label}} is required","any.unknown":"{{#label}} is not allowed"}})},546:(j,$,b)=>{"use strict";const l=b(375),y=b(9474),d=b(9621),f=b(8068),e=b(8160),i=b(3292),n={};j.exports=f.extend({type:"array",flags:{single:{default:!1},sparse:{default:!1}},terms:{items:{init:[],manifest:"schema"},ordered:{init:[],manifest:"schema"},_exclusions:{init:[]},_inclusions:{init:[]},_requireds:{init:[]}},coerce:{from:"object",method(r,{schema:t,state:o,prefs:s}){if(!Array.isArray(r))return;const a=t.$_getRule("sort");return a?n.sort(t,r,a.args.options,o,s):void 0}},validate(r,{schema:t,error:o}){if(!Array.isArray(r)){if(t._flags.single){const s=[r];return s[e.symbols.arraySingle]=!0,{value:s}}return{errors:o("array.base")}}if(t.$_getRule("items")||t.$_terms.externals)return{value:r.slice()}},rules:{has:{method(r){r=this.$_compile(r,{appendPath:!0});const t=this.$_addRule({name:"has",args:{schema:r}});return t.$_mutateRegister(r),t},validate(r,{state:t,prefs:o,error:s},{schema:a}){const c=[r,...t.ancestors];for(let p=0;p<r.length;++p){const _=t.localize([...t.path,p],c,a);if(a.$_match(r[p],_,o))return r}const h=a._flags.label;return h?s("array.hasKnown",{patternLabel:h}):s("array.hasUnknown",null)},multi:!0},items:{method(...r){e.verifyFlat(r,"items");const t=this.$_addRule("items");for(let o=0;o<r.length;++o){const s=e.tryWithPath(()=>this.$_compile(r[o]),o,{append:!0});t.$_terms.items.push(s)}return t.$_mutateRebuild()},validate(r,{schema:t,error:o,state:s,prefs:a,errorsArray:c}){const h=t.$_terms._requireds.slice(),p=t.$_terms.ordered.slice(),_=[...t.$_terms._inclusions,...h],v=!r[e.symbols.arraySingle];delete r[e.symbols.arraySingle];const u=c();let m=r.length;for(let g=0;g<m;++g){const w=r[g];let x=!1,k=!1;const R=v?g:new Number(g),S=[...s.path,R];if(!t._flags.sparse&&void 0===w){if(u.push(o("array.sparse",{key:R,path:S,pos:g,value:void 0},s.localize(S))),a.abortEarly)return u;p.shift();continue}const E=[r,...s.ancestors];for(const A of t.$_terms._exclusions)if(A.$_match(w,s.localize(S,E,A),a,{presence:"ignore"})){if(u.push(o("array.excludes",{pos:g,value:w},s.localize(S))),a.abortEarly)return u;x=!0,p.shift();break}if(x)continue;if(t.$_terms.ordered.length){if(p.length){const A=p.shift(),O=A.$_validate(w,s.localize(S,E,A),a);if(O.errors){if(u.push(...O.errors),a.abortEarly)return u}else if("strip"===A._flags.result)n.fastSplice(r,g),--g,--m;else{if(!t._flags.sparse&&void 0===O.value){if(u.push(o("array.sparse",{key:R,path:S,pos:g,value:void 0},s.localize(S))),a.abortEarly)return u;continue}r[g]=O.value}continue}if(!t.$_terms.items.length){if(u.push(o("array.orderedLength",{pos:g,limit:t.$_terms.ordered.length})),a.abortEarly)return u;break}}const D=[];let I=h.length;for(let A=0;A<I;++A){const O=s.localize(S,E,h[A]);O.snapshot();const C=h[A].$_validate(w,O,a);if(D[A]=C,!C.errors){if(O.commit(),r[g]=C.value,k=!0,n.fastSplice(h,A),--A,--I,!t._flags.sparse&&void 0===C.value&&(u.push(o("array.sparse",{key:R,path:S,pos:g,value:void 0},s.localize(S))),a.abortEarly))return u;break}O.restore()}if(k)continue;const M=a.stripUnknown&&!!a.stripUnknown.arrays||!1;I=_.length;for(const A of _){let O;const C=h.indexOf(A);if(-1!==C)O=D[C];else{const P=s.localize(S,E,A);if(P.snapshot(),O=A.$_validate(w,P,a),!O.errors){P.commit(),"strip"===A._flags.result?(n.fastSplice(r,g),--g,--m):t._flags.sparse||void 0!==O.value?r[g]=O.value:(u.push(o("array.sparse",{key:R,path:S,pos:g,value:void 0},s.localize(S))),x=!0),k=!0;break}P.restore()}if(1===I){if(M){n.fastSplice(r,g),--g,--m,k=!0;break}if(u.push(...O.errors),a.abortEarly)return u;x=!0;break}}if(!x&&(t.$_terms._inclusions.length||t.$_terms._requireds.length)&&!k){if(M){n.fastSplice(r,g),--g,--m;continue}if(u.push(o("array.includes",{pos:g,value:w},s.localize(S))),a.abortEarly)return u}}return h.length&&n.fillMissedErrors(t,u,h,r,s,a),p.length&&(n.fillOrderedErrors(t,u,p,r,s,a),u.length||n.fillDefault(p,r,s,a)),u.length?u:r},priority:!0,manifest:!1},length:{method(r){return this.$_addRule({name:"length",args:{limit:r},operator:"="})},validate:(r,t,{limit:o},{name:s,operator:a,args:c})=>e.compare(r.length,o,a)?r:t.error("array."+s,{limit:c.limit,value:r}),args:[{name:"limit",ref:!0,assert:e.limit,message:"must be a positive integer"}]},max:{method(r){return this.$_addRule({name:"max",method:"length",args:{limit:r},operator:"<="})}},min:{method(r){return this.$_addRule({name:"min",method:"length",args:{limit:r},operator:">="})}},ordered:{method(...r){e.verifyFlat(r,"ordered");const t=this.$_addRule("items");for(let o=0;o<r.length;++o){const s=e.tryWithPath(()=>this.$_compile(r[o]),o,{append:!0});n.validateSingle(s,t),t.$_mutateRegister(s),t.$_terms.ordered.push(s)}return t.$_mutateRebuild()}},single:{method(r){const t=void 0===r||!!r;return l(!t||!this._flags._arrayItems,"Cannot specify single rule when array has array items"),this.$_setFlag("single",t)}},sort:{method(r={}){e.assertOptions(r,["by","order"]);const t={order:r.order||"ascending"};return r.by&&(t.by=i.ref(r.by,{ancestor:0}),l(!t.by.ancestor,"Cannot sort by ancestor")),this.$_addRule({name:"sort",args:{options:t}})},validate(r,{error:t,state:o,prefs:s,schema:a},{options:c}){const{value:h,errors:p}=n.sort(a,r,c,o,s);if(p)return p;for(let _=0;_<r.length;++_)if(r[_]!==h[_])return t("array.sort",{order:c.order,by:c.by?c.by.key:"value"});return r},convert:!0},sparse:{method(r){const t=void 0===r||!!r;return this._flags.sparse===t?this:(t?this.clone():this.$_addRule("items")).$_setFlag("sparse",t,{clone:!1})}},unique:{method(r,t={}){l(!r||"function"==typeof r||"string"==typeof r,"comparator must be a function or a string"),e.assertOptions(t,["ignoreUndefined","separator"]);const o={name:"unique",args:{options:t,comparator:r}};if(r)if("string"==typeof r){const s=e.default(t.separator,".");o.path=s?r.split(s):[r]}else o.comparator=r;return this.$_addRule(o)},validate(r,{state:t,error:o},{comparator:a,options:c},{comparator:h,path:p}){const _={string:Object.create(null),number:Object.create(null),undefined:Object.create(null),boolean:Object.create(null),object:new Map,function:new Map,custom:new Map},v=h||y,u=c.ignoreUndefined;for(let m=0;m<r.length;++m){const g=p?d(r[m],p):r[m],w=h?_.custom:_[typeof g];if(l(w,"Failed to find unique map container for type",typeof g),w instanceof Map){const x=w.entries();let k;for(;!(k=x.next()).done;)if(v(k.value[0],g)){const R=t.localize([...t.path,m],[r,...t.ancestors]),S={pos:m,value:r[m],dupePos:k.value[1],dupeValue:r[k.value[1]]};return p&&(S.path=a),o("array.unique",S,R)}w.set(g,m)}else{if((!u||void 0!==g)&&void 0!==w[g]){const x={pos:m,value:r[m],dupePos:w[g],dupeValue:r[w[g]]};return p&&(x.path=a),o("array.unique",x,t.localize([...t.path,m],[r,...t.ancestors]))}w[g]=m}}return r},args:["comparator","options"],multi:!0}},cast:{set:{from:Array.isArray,to:(r,t)=>new Set(r)}},rebuild(r){r.$_terms._inclusions=[],r.$_terms._exclusions=[],r.$_terms._requireds=[];for(const t of r.$_terms.items)n.validateSingle(t,r),"required"===t._flags.presence?r.$_terms._requireds.push(t):"forbidden"===t._flags.presence?r.$_terms._exclusions.push(t):r.$_terms._inclusions.push(t);for(const t of r.$_terms.ordered)n.validateSingle(t,r)},manifest:{build:(r,t)=>(t.items&&(r=r.items(...t.items)),t.ordered&&(r=r.ordered(...t.ordered)),r)},messages:{"array.base":"{{#label}} must be an array","array.excludes":"{{#label}} contains an excluded value","array.hasKnown":"{{#label}} does not contain at least one required match for type {:#patternLabel}","array.hasUnknown":"{{#label}} does not contain at least one required match","array.includes":"{{#label}} does not match any of the allowed types","array.includesRequiredBoth":"{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)","array.includesRequiredKnowns":"{{#label}} does not contain {{#knownMisses}}","array.includesRequiredUnknowns":"{{#label}} does not contain {{#unknownMisses}} required value(s)","array.length":"{{#label}} must contain {{#limit}} items","array.max":"{{#label}} must contain less than or equal to {{#limit}} items","array.min":"{{#label}} must contain at least {{#limit}} items","array.orderedLength":"{{#label}} must contain at most {{#limit}} items","array.sort":"{{#label}} must be sorted in {#order} order by {{#by}}","array.sort.mismatching":"{{#label}} cannot be sorted due to mismatching types","array.sort.unsupported":"{{#label}} cannot be sorted due to unsupported type {#type}","array.sparse":"{{#label}} must not be a sparse array item","array.unique":"{{#label}} contains a duplicate value"}}),n.fillMissedErrors=function(r,t,o,s,a,c){const h=[];let p=0;for(const _ of o){const v=_._flags.label;v?h.push(v):++p}t.push(h.length?p?r.$_createError("array.includesRequiredBoth",s,{knownMisses:h,unknownMisses:p},a,c):r.$_createError("array.includesRequiredKnowns",s,{knownMisses:h},a,c):r.$_createError("array.includesRequiredUnknowns",s,{unknownMisses:p},a,c))},n.fillOrderedErrors=function(r,t,o,s,a,c){const h=[];for(const p of o)"required"===p._flags.presence&&h.push(p);h.length&&n.fillMissedErrors(r,t,h,s,a,c)},n.fillDefault=function(r,t,o,s){const a=[];let c=!0;for(let h=r.length-1;h>=0;--h){const p=r[h],_=[t,...o.ancestors],v=p.$_validate(void 0,o.localize(o.path,_,p),s).value;if(c){if(void 0===v)continue;c=!1}a.unshift(v)}a.length&&t.push(...a)},n.fastSplice=function(r,t){let o=t;for(;o<r.length;)r[o++]=r[o];--r.length},n.validateSingle=function(r,t){("array"===r.type||r._flags._arrayItems)&&(l(!t._flags.single,"Cannot specify array item with single rule enabled"),t.$_setFlag("_arrayItems",!0,{clone:!1}))},n.sort=function(r,t,o,s,a){const c="ascending"===o.order?1:-1,h=-1*c,p=c,_=(v,u)=>{let m=n.compare(v,u,h,p);if(null!==m||(o.by&&(v=o.by.resolve(v,s,a),u=o.by.resolve(u,s,a)),m=n.compare(v,u,h,p),null!==m))return m;const g=typeof v;if(g!==typeof u)throw r.$_createError("array.sort.mismatching",t,null,s,a);if("number"!==g&&"string"!==g)throw r.$_createError("array.sort.unsupported",t,{type:g},s,a);return"number"===g?(v-u)*c:v<u?h:p};try{return{value:t.slice().sort(_)}}catch(v){return{errors:v}}},n.compare=function(r,t,o,s){return r===t?0:void 0===r?1:void 0===t?-1:null===r?s:null===t?o:null}},4937:(j,$,b)=>{"use strict";const l=b(375),y=b(8068),d=b(8160),f=b(2036),e={isBool:function(i){return"boolean"==typeof i}};j.exports=y.extend({type:"boolean",flags:{sensitive:{default:!1}},terms:{falsy:{init:null,manifest:"values"},truthy:{init:null,manifest:"values"}},coerce(i,{schema:n}){if("boolean"!=typeof i){if("string"==typeof i){const r=n._flags.sensitive?i:i.toLowerCase();i="true"===r||"false"!==r&&i}return"boolean"!=typeof i&&(i=n.$_terms.truthy&&n.$_terms.truthy.has(i,null,null,!n._flags.sensitive)||(!n.$_terms.falsy||!n.$_terms.falsy.has(i,null,null,!n._flags.sensitive))&&i),{value:i}}},validate(i,{error:n}){if("boolean"!=typeof i)return{value:i,errors:n("boolean.base")}},rules:{truthy:{method(...i){d.verifyFlat(i,"truthy");const n=this.clone();n.$_terms.truthy=n.$_terms.truthy||new f;for(let r=0;r<i.length;++r){const t=i[r];l(void 0!==t,"Cannot call truthy with undefined"),n.$_terms.truthy.add(t)}return n}},falsy:{method(...i){d.verifyFlat(i,"falsy");const n=this.clone();n.$_terms.falsy=n.$_terms.falsy||new f;for(let r=0;r<i.length;++r){const t=i[r];l(void 0!==t,"Cannot call falsy with undefined"),n.$_terms.falsy.add(t)}return n}},sensitive:{method(i=!0){return this.$_setFlag("sensitive",i)}}},cast:{number:{from:e.isBool,to:(i,n)=>i?1:0},string:{from:e.isBool,to:(i,n)=>i?"true":"false"}},manifest:{build:(i,n)=>(n.truthy&&(i=i.truthy(...n.truthy)),n.falsy&&(i=i.falsy(...n.falsy)),i)},messages:{"boolean.base":"{{#label}} must be a boolean"}})},7500:(j,$,b)=>{"use strict";const l=b(375),y=b(8068),d=b(8160),f=b(3328),e={isDate:function(i){return i instanceof Date}};j.exports=y.extend({type:"date",coerce:{from:["number","string"],method:(i,{schema:n})=>({value:e.parse(i,n._flags.format)||i})},validate(i,{schema:n,error:r,prefs:t}){if(i instanceof Date&&!isNaN(i.getTime()))return;const o=n._flags.format;return t.convert&&o&&"string"==typeof i?{value:i,errors:r("date.format",{format:o})}:{value:i,errors:r("date.base")}},rules:{compare:{method:!1,validate(i,n,{date:r},{name:t,operator:o,args:s}){const a="now"===r?Date.now():r.getTime();return d.compare(i.getTime(),a,o)?i:n.error("date."+t,{limit:s.date,value:i})},args:[{name:"date",ref:!0,normalize:i=>"now"===i?i:e.parse(i),assert:i=>null!==i,message:"must have a valid date format"}]},format:{method(i){return l(["iso","javascript","unix"].includes(i),"Unknown date format",i),this.$_setFlag("format",i)}},greater:{method(i){return this.$_addRule({name:"greater",method:"compare",args:{date:i},operator:">"})}},iso:{method(){return this.format("iso")}},less:{method(i){return this.$_addRule({name:"less",method:"compare",args:{date:i},operator:"<"})}},max:{method(i){return this.$_addRule({name:"max",method:"compare",args:{date:i},operator:"<="})}},min:{method(i){return this.$_addRule({name:"min",method:"compare",args:{date:i},operator:">="})}},timestamp:{method(i="javascript"){return l(["javascript","unix"].includes(i),'"type" must be one of "javascript, unix"'),this.format(i)}}},cast:{number:{from:e.isDate,to:(i,n)=>i.getTime()},string:{from:e.isDate,to:(i,{prefs:n})=>f.date(i,n)}},messages:{"date.base":"{{#label}} must be a valid date","date.format":'{{#label}} must be in {msg("date.format." + #format) || #format} format',"date.greater":"{{#label}} must be greater than {{:#limit}}","date.less":"{{#label}} must be less than {{:#limit}}","date.max":"{{#label}} must be less than or equal to {{:#limit}}","date.min":"{{#label}} must be greater than or equal to {{:#limit}}","date.format.iso":"ISO 8601 date","date.format.javascript":"timestamp or number of milliseconds","date.format.unix":"timestamp or number of seconds"}}),e.parse=function(i,n){if(i instanceof Date)return i;if("string"!=typeof i&&(isNaN(i)||!isFinite(i))||/^\s*$/.test(i))return null;if("iso"===n)return d.isIsoDate(i)?e.date(i.toString()):null;const r=i;if("string"==typeof i&&/^[+-]?\d+(\.\d+)?$/.test(i)&&(i=parseFloat(i)),n){if("javascript"===n)return e.date(1*i);if("unix"===n)return e.date(1e3*i);if("string"==typeof r)return null}return e.date(i)},e.date=function(i){const n=new Date(i);return isNaN(n.getTime())?null:n}},390:(j,$,b)=>{"use strict";const l=b(375),y=b(7824);j.exports=y.extend({type:"function",properties:{typeof:"function"},rules:{arity:{method(d){return l(Number.isSafeInteger(d)&&d>=0,"n must be a positive integer"),this.$_addRule({name:"arity",args:{n:d}})},validate:(d,f,{n:e})=>d.length===e?d:f.error("function.arity",{n:e})},class:{method(){return this.$_addRule("class")},validate:(d,f)=>/^\s*class\s/.test(d.toString())?d:f.error("function.class",{value:d})},minArity:{method(d){return l(Number.isSafeInteger(d)&&d>0,"n must be a strict positive integer"),this.$_addRule({name:"minArity",args:{n:d}})},validate:(d,f,{n:e})=>d.length>=e?d:f.error("function.minArity",{n:e})},maxArity:{method(d){return l(Number.isSafeInteger(d)&&d>=0,"n must be a positive integer"),this.$_addRule({name:"maxArity",args:{n:d}})},validate:(d,f,{n:e})=>d.length<=e?d:f.error("function.maxArity",{n:e})}},messages:{"function.arity":"{{#label}} must have an arity of {{#n}}","function.class":"{{#label}} must be a class","function.maxArity":"{{#label}} must have an arity lesser or equal to {{#n}}","function.minArity":"{{#label}} must have an arity greater or equal to {{#n}}"}})},7824:(j,$,b)=>{"use strict";const l=b(978),y=b(375),d=b(8571),f=b(3652),e=b(8068),i=b(8160),n=b(3292),r=b(6354),t=b(6133),o=b(3328),s={renameDefaults:{alias:!1,multiple:!1,override:!1}};j.exports=e.extend({type:"_keys",properties:{typeof:"object"},flags:{unknown:{default:!1}},terms:{dependencies:{init:null},keys:{init:null,manifest:{mapped:{from:"schema",to:"key"}}},patterns:{init:null},renames:{init:null}},args:(a,c)=>a.keys(c),validate(a,{schema:c,error:h,state:p,prefs:_}){if(!a||typeof a!==c.$_property("typeof")||Array.isArray(a))return{value:a,errors:h("object.base",{type:c.$_property("typeof")})};if(!(c.$_terms.renames||c.$_terms.dependencies||c.$_terms.keys||c.$_terms.patterns||c.$_terms.externals))return;a=s.clone(a,_);const v=[];if(c.$_terms.renames&&!s.rename(c,a,p,_,v))return{value:a,errors:v};if(!c.$_terms.keys&&!c.$_terms.patterns&&!c.$_terms.dependencies)return{value:a,errors:v};const u=new Set(Object.keys(a));if(c.$_terms.keys){const m=[a,...p.ancestors];for(const g of c.$_terms.keys){const w=g.key,x=a[w];u.delete(w);const k=p.localize([...p.path,w],m,g),R=g.schema.$_validate(x,k,_);if(R.errors){if(_.abortEarly)return{value:a,errors:R.errors};void 0!==R.value&&(a[w]=R.value),v.push(...R.errors)}else"strip"===g.schema._flags.result||void 0===R.value&&void 0!==x?delete a[w]:void 0!==R.value&&(a[w]=R.value)}}if(u.size||c._flags._hasPatternMatch){const m=s.unknown(c,a,u,v,p,_);if(m)return m}if(c.$_terms.dependencies)for(const m of c.$_terms.dependencies){if(null!==m.key&&!1===s.isPresent(m.options)(m.key.resolve(a,p,_,null,{shadow:!1})))continue;const g=s.dependencies[m.rel](c,m,a,p,_);if(g){const w=c.$_createError(g.code,a,g.context,p,_);if(_.abortEarly)return{value:a,errors:w};v.push(w)}}return{value:a,errors:v}},rules:{and:{method(...a){return i.verifyFlat(a,"and"),s.dependency(this,"and",null,a)}},append:{method(a){return null==a||0===Object.keys(a).length?this:this.keys(a)}},assert:{method(a,c,h){o.isTemplate(a)||(a=n.ref(a)),y(void 0===h||"string"==typeof h,"Message must be a string"),c=this.$_compile(c,{appendPath:!0});const p=this.$_addRule({name:"assert",args:{subject:a,schema:c,message:h}});return p.$_mutateRegister(a),p.$_mutateRegister(c),p},validate(a,{error:c,prefs:h,state:p},{subject:_,schema:v,message:u}){const m=_.resolve(a,p,h),g=t.isRef(_)?_.absolute(p):[];return v.$_match(m,p.localize(g,[a,...p.ancestors],v),h)?a:c("object.assert",{subject:_,message:u})},args:["subject","schema","message"],multi:!0},instance:{method(a,c){return y("function"==typeof a,"constructor must be a function"),this.$_addRule({name:"instance",args:{constructor:a,name:c=c||a.name}})},validate:(a,c,{constructor:h,name:p})=>a instanceof h?a:c.error("object.instance",{type:p,value:a}),args:["constructor","name"]},keys:{method(a){y(void 0===a||"object"==typeof a,"Object schema must be a valid object"),y(!i.isSchema(a),"Object schema cannot be a joi schema");const c=this.clone();if(a)if(Object.keys(a).length){c.$_terms.keys=c.$_terms.keys?c.$_terms.keys.filter(h=>!a.hasOwnProperty(h.key)):new s.Keys;for(const h in a)i.tryWithPath(()=>c.$_terms.keys.push({key:h,schema:this.$_compile(a[h])}),h)}else c.$_terms.keys=new s.Keys;else c.$_terms.keys=null;return c.$_mutateRebuild()}},length:{method(a){return this.$_addRule({name:"length",args:{limit:a},operator:"="})},validate:(a,c,{limit:h},{name:p,operator:_,args:v})=>i.compare(Object.keys(a).length,h,_)?a:c.error("object."+p,{limit:v.limit,value:a}),args:[{name:"limit",ref:!0,assert:i.limit,message:"must be a positive integer"}]},max:{method(a){return this.$_addRule({name:"max",method:"length",args:{limit:a},operator:"<="})}},min:{method(a){return this.$_addRule({name:"min",method:"length",args:{limit:a},operator:">="})}},nand:{method(...a){return i.verifyFlat(a,"nand"),s.dependency(this,"nand",null,a)}},or:{method(...a){return i.verifyFlat(a,"or"),s.dependency(this,"or",null,a)}},oxor:{method(...a){return s.dependency(this,"oxor",null,a)}},pattern:{method(a,c,h={}){const p=a instanceof RegExp;p||(a=this.$_compile(a,{appendPath:!0})),y(void 0!==c,"Invalid rule"),i.assertOptions(h,["fallthrough","matches"]),p&&y(!a.flags.includes("g")&&!a.flags.includes("y"),"pattern should not use global or sticky mode"),c=this.$_compile(c,{appendPath:!0});const _=this.clone();_.$_terms.patterns=_.$_terms.patterns||[];const v={[p?"regex":"schema"]:a,rule:c};return h.matches&&(v.matches=this.$_compile(h.matches),"array"!==v.matches.type&&(v.matches=v.matches.$_root.array().items(v.matches)),_.$_mutateRegister(v.matches),_.$_setFlag("_hasPatternMatch",!0,{clone:!1})),h.fallthrough&&(v.fallthrough=!0),_.$_terms.patterns.push(v),_.$_mutateRegister(c),_}},ref:{method(){return this.$_addRule("ref")},validate:(a,c)=>t.isRef(a)?a:c.error("object.refType",{value:a})},regex:{method(){return this.$_addRule("regex")},validate:(a,c)=>a instanceof RegExp?a:c.error("object.regex",{value:a})},rename:{method(a,c,h={}){y("string"==typeof a||a instanceof RegExp,"Rename missing the from argument"),y("string"==typeof c||c instanceof o,"Invalid rename to argument"),y(c!==a,"Cannot rename key to same name:",a),i.assertOptions(h,["alias","ignoreUndefined","override","multiple"]);const p=this.clone();p.$_terms.renames=p.$_terms.renames||[];for(const _ of p.$_terms.renames)y(_.from!==a,"Cannot rename the same key multiple times");return c instanceof o&&p.$_mutateRegister(c),p.$_terms.renames.push({from:a,to:c,options:l(s.renameDefaults,h)}),p}},schema:{method(a="any"){return this.$_addRule({name:"schema",args:{type:a}})},validate:(a,c,{type:h})=>!i.isSchema(a)||"any"!==h&&a.type!==h?c.error("object.schema",{type:h}):a},unknown:{method(a){return this.$_setFlag("unknown",!1!==a)}},with:{method(a,c,h={}){return s.dependency(this,"with",a,c,h)}},without:{method(a,c,h={}){return s.dependency(this,"without",a,c,h)}},xor:{method(...a){return i.verifyFlat(a,"xor"),s.dependency(this,"xor",null,a)}}},overrides:{default(a,c){return void 0===a&&(a=i.symbols.deepDefault),this.$_parent("default",a,c)}},rebuild(a){if(a.$_terms.keys){const c=new f.Sorter;for(const h of a.$_terms.keys)i.tryWithPath(()=>c.add(h,{after:h.schema.$_rootReferences(),group:h.key}),h.key);a.$_terms.keys=new s.Keys(...c.nodes)}},manifest:{build(a,c){if(c.keys&&(a=a.keys(c.keys)),c.dependencies)for(const{rel:h,key:p=null,peers:_,options:v}of c.dependencies)a=s.dependency(a,h,p,_,v);if(c.patterns)for(const{regex:h,schema:p,rule:_,fallthrough:v,matches:u}of c.patterns)a=a.pattern(h||p,_,{fallthrough:v,matches:u});if(c.renames)for(const{from:h,to:p,options:_}of c.renames)a=a.rename(h,p,_);return a}},messages:{"object.and":"{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}","object.assert":'{{#label}} is invalid because {if(#subject.key, `"` + #subject.key + `" failed to ` + (#message || "pass the assertion test"), #message || "the assertion failed")}',"object.base":"{{#label}} must be of type {{#type}}","object.instance":"{{#label}} must be an instance of {{:#type}}","object.length":'{{#label}} must have {{#limit}} key{if(#limit == 1, "", "s")}',"object.max":'{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, "", "s")}',"object.min":'{{#label}} must have at least {{#limit}} key{if(#limit == 1, "", "s")}',"object.missing":"{{#label}} must contain at least one of {{#peersWithLabels}}","object.nand":"{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}","object.oxor":"{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}","object.pattern.match":"{{#label}} keys failed to match pattern requirements","object.refType":"{{#label}} must be a Joi reference","object.regex":"{{#label}} must be a RegExp object","object.rename.multiple":"{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}","object.rename.override":"{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists","object.schema":"{{#label}} must be a Joi schema of {{#type}} type","object.unknown":"{{#label}} is not allowed","object.with":"{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}","object.without":"{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}","object.xor":"{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}"}}),s.clone=function(a,c){if("object"==typeof a){if(c.nonEnumerables)return d(a,{shallow:!0});const p=Object.create(Object.getPrototypeOf(a));return Object.assign(p,a),p}const h=function(...p){return a.apply(this,p)};return h.prototype=d(a.prototype),Object.defineProperty(h,"name",{value:a.name,writable:!1}),Object.defineProperty(h,"length",{value:a.length,writable:!1}),Object.assign(h,a),h},s.dependency=function(a,c,h,p,_){y(null===h||"string"==typeof h,c,"key must be a strings"),_||(_=p.length>1&&"object"==typeof p[p.length-1]?p.pop():{}),i.assertOptions(_,["separator","isPresent"]),p=[].concat(p);const v=i.default(_.separator,"."),u=[];for(const g of p)y("string"==typeof g,c,"peers must be strings"),u.push(n.ref(g,{separator:v,ancestor:0,prefix:!1}));null!==h&&(h=n.ref(h,{separator:v,ancestor:0,prefix:!1}));const m=a.clone();return m.$_terms.dependencies=m.$_terms.dependencies||[],m.$_terms.dependencies.push(new s.Dependency(c,h,u,p,_)),m},s.dependencies={and(a,c,h,p,_){const v=[],u=[],m=c.peers.length,g=s.isPresent(c.options);for(const w of c.peers)!1===g(w.resolve(h,p,_,null,{shadow:!1}))?v.push(w.key):u.push(w.key);if(v.length!==m&&u.length!==m)return{code:"object.and",context:{present:u,presentWithLabels:s.keysToLabels(a,u),missing:v,missingWithLabels:s.keysToLabels(a,v)}}},nand(a,c,h,p,_){const v=[],u=s.isPresent(c.options);for(const w of c.peers)u(w.resolve(h,p,_,null,{shadow:!1}))&&v.push(w.key);if(v.length!==c.peers.length)return;const m=c.paths[0],g=c.paths.slice(1);return{code:"object.nand",context:{main:m,mainWithLabel:s.keysToLabels(a,m),peers:g,peersWithLabels:s.keysToLabels(a,g)}}},or(a,c,h,p,_){const v=s.isPresent(c.options);for(const u of c.peers)if(v(u.resolve(h,p,_,null,{shadow:!1})))return;return{code:"object.missing",context:{peers:c.paths,peersWithLabels:s.keysToLabels(a,c.paths)}}},oxor(a,c,h,p,_){const v=[],u=s.isPresent(c.options);for(const g of c.peers)u(g.resolve(h,p,_,null,{shadow:!1}))&&v.push(g.key);if(!v.length||1===v.length)return;const m={peers:c.paths,peersWithLabels:s.keysToLabels(a,c.paths)};return m.present=v,m.presentWithLabels=s.keysToLabels(a,v),{code:"object.oxor",context:m}},with(a,c,h,p,_){const v=s.isPresent(c.options);for(const u of c.peers)if(!1===v(u.resolve(h,p,_,null,{shadow:!1})))return{code:"object.with",context:{main:c.key.key,mainWithLabel:s.keysToLabels(a,c.key.key),peer:u.key,peerWithLabel:s.keysToLabels(a,u.key)}}},without(a,c,h,p,_){const v=s.isPresent(c.options);for(const u of c.peers)if(v(u.resolve(h,p,_,null,{shadow:!1})))return{code:"object.without",context:{main:c.key.key,mainWithLabel:s.keysToLabels(a,c.key.key),peer:u.key,peerWithLabel:s.keysToLabels(a,u.key)}}},xor(a,c,h,p,_){const v=[],u=s.isPresent(c.options);for(const g of c.peers)u(g.resolve(h,p,_,null,{shadow:!1}))&&v.push(g.key);if(1===v.length)return;const m={peers:c.paths,peersWithLabels:s.keysToLabels(a,c.paths)};return 0===v.length?{code:"object.missing",context:m}:(m.present=v,m.presentWithLabels=s.keysToLabels(a,v),{code:"object.xor",context:m})}},s.keysToLabels=function(a,c){return Array.isArray(c)?c.map(h=>a.$_mapLabels(h)):a.$_mapLabels(c)},s.isPresent=function(a){return"function"==typeof a.isPresent?a.isPresent:c=>void 0!==c},s.rename=function(a,c,h,p,_){const v={};for(const u of a.$_terms.renames){const m=[],g="string"!=typeof u.from;if(g)for(const w in c){if(void 0===c[w]&&u.options.ignoreUndefined||w===u.to)continue;const x=u.from.exec(w);x&&m.push({from:w,to:u.to,match:x})}else!Object.prototype.hasOwnProperty.call(c,u.from)||void 0===c[u.from]&&u.options.ignoreUndefined||m.push(u);for(const w of m){const x=w.from;let k=w.to;if(k instanceof o&&(k=k.render(c,h,p,w.match)),x!==k){if(!u.options.multiple&&v[k]&&(_.push(a.$_createError("object.rename.multiple",c,{from:x,to:k,pattern:g},h,p)),p.abortEarly)||Object.prototype.hasOwnProperty.call(c,k)&&!u.options.override&&!v[k]&&(_.push(a.$_createError("object.rename.override",c,{from:x,to:k,pattern:g},h,p)),p.abortEarly))return!1;void 0===c[x]?delete c[k]:c[k]=c[x],v[k]=!0,u.options.alias||delete c[x]}}}return!0},s.unknown=function(a,c,h,p,_,v){if(a.$_terms.patterns){let u=!1;const m=a.$_terms.patterns.map(w=>{if(w.matches)return u=!0,[]}),g=[c,..._.ancestors];for(const w of h){const x=c[w],k=[..._.path,w];for(let R=0;R<a.$_terms.patterns.length;++R){const S=a.$_terms.patterns[R];if(S.regex){const I=S.regex.test(w);if(_.mainstay.tracer.debug(_,"rule",`pattern.${R}`,I?"pass":"error"),!I)continue}else if(!S.schema.$_match(w,_.nest(S.schema,`pattern.${R}`),v))continue;h.delete(w);const E=_.localize(k,g,{schema:S.rule,key:w}),D=S.rule.$_validate(x,E,v);if(D.errors){if(v.abortEarly)return{value:c,errors:D.errors};p.push(...D.errors)}if(S.matches&&m[R].push(w),c[w]=D.value,!S.fallthrough)break}}if(u)for(let w=0;w<m.length;++w){const x=m[w];if(!x)continue;const k=a.$_terms.patterns[w].matches,R=_.localize(_.path,g,k),S=k.$_validate(x,R,v);if(S.errors){const E=r.details(S.errors,{override:!1});E.matches=x;const D=a.$_createError("object.pattern.match",c,E,_,v);if(v.abortEarly)return{value:c,errors:D};p.push(D)}}}if(h.size&&(a.$_terms.keys||a.$_terms.patterns)){if(v.stripUnknown&&!a._flags.unknown||v.skipFunctions){const u=!(!v.stripUnknown||!0!==v.stripUnknown&&!v.stripUnknown.objects);for(const m of h)u?(delete c[m],h.delete(m)):"function"==typeof c[m]&&h.delete(m)}if(!i.default(a._flags.unknown,v.allowUnknown))for(const u of h){const m=_.localize([..._.path,u],[]),g=a.$_createError("object.unknown",c[u],{child:u},m,v,{flags:!1});if(v.abortEarly)return{value:c,errors:g};p.push(g)}}},s.Dependency=class{constructor(a,c,h,p,_){this.rel=a,this.key=c,this.peers=h,this.paths=p,this.options=_}describe(){const a={rel:this.rel,peers:this.paths};return null!==this.key&&(a.key=this.key.key),"."!==this.peers[0].separator&&(a.options={...a.options,separator:this.peers[0].separator}),this.options.isPresent&&(a.options={...a.options,isPresent:this.options.isPresent}),a}},s.Keys=class extends Array{concat(a){const c=this.slice(),h=new Map;for(let p=0;p<c.length;++p)h.set(c[p].key,p);for(const p of a){const _=p.key,v=h.get(_);void 0!==v?c[v]={key:_,schema:c[v].schema.concat(p.schema)}:c.push(p)}return c}}},8785:(j,$,b)=>{"use strict";const l=b(375),y=b(8068),d=b(8160),f=b(3292),e=b(6354),i={};j.exports=y.extend({type:"link",properties:{schemaChain:!0},terms:{link:{init:null,manifest:"single",register:!1}},args:(n,r)=>n.ref(r),validate(n,{schema:r,state:t,prefs:o}){l(r.$_terms.link,"Uninitialized link schema");const s=i.generate(r,n,t,o);return s.$_validate(n,t.nest(s,`link:${r.$_terms.link[0].ref.display}:${s.type}`),o)},generate:(n,r,t,o)=>i.generate(n,r,t,o),rules:{ref:{method(n){l(!this.$_terms.link,"Cannot reinitialize schema"),n=f.ref(n),l("value"===n.type||"local"===n.type,"Invalid reference type:",n.type),l("local"===n.type||"root"===n.ancestor||n.ancestor>0,"Link cannot reference itself");const r=this.clone();return r.$_terms.link=[{ref:n}],r}},relative:{method(n=!0){return this.$_setFlag("relative",n)}}},overrides:{concat(n){l(this.$_terms.link,"Uninitialized link schema"),l(d.isSchema(n),"Invalid schema object"),l("link"!==n.type,"Cannot merge type link with another link");const r=this.clone();return r.$_terms.whens||(r.$_terms.whens=[]),r.$_terms.whens.push({concat:n}),r.$_mutateRebuild()}},manifest:{build:(n,r)=>(l(r.link,"Invalid link description missing link"),n.ref(r.link))}}),i.generate=function(n,r,t,o){let s=t.mainstay.links.get(n);if(s)return s._generate(r,t,o).schema;const a=n.$_terms.link[0].ref,{perspective:c,path:h}=i.perspective(a,t);i.assert(c,"which is outside of schema boundaries",a,n,t,o);try{s=h.length?c.$_reach(h):c}catch{i.assert(!1,"to non-existing schema",a,n,t,o)}return i.assert("link"!==s.type,"which is another link",a,n,t,o),n._flags.relative||t.mainstay.links.set(n,s),s._generate(r,t,o).schema},i.perspective=function(n,r){if("local"===n.type){for(const{schema:t,key:o}of r.schemas){if((t._flags.id||o)===n.path[0])return{perspective:t,path:n.path.slice(1)};if(t.$_terms.shared)for(const s of t.$_terms.shared)if(s._flags.id===n.path[0])return{perspective:s,path:n.path.slice(1)}}return{perspective:null,path:null}}return"root"===n.ancestor?{perspective:r.schemas[r.schemas.length-1].schema,path:n.path}:{perspective:r.schemas[n.ancestor]&&r.schemas[n.ancestor].schema,path:n.path}},i.assert=function(n,r,t,o,s,a){n||l(!1,`"${e.label(o._flags,s,a)}" contains link reference "${t.display}" ${r}`)}},3832:(j,$,b)=>{"use strict";const l=b(375),y=b(8068),d=b(8160),f={numberRx:/^\s*[+-]?(?:(?:\d+(?:\.\d*)?)|(?:\.\d+))(?:e([+-]?\d+))?\s*$/i,precisionRx:/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/,exponentialPartRegex:/[eE][+-]?\d+$/,leadingSignAndZerosRegex:/^[+-]?(0*)?/,dotRegex:/\./,trailingZerosRegex:/0+$/,decimalPlaces(e){const i=e.toString(),n=i.indexOf("."),r=i.indexOf("e");return(n<0?0:(r<0?i.length:r)-n-1)+(r<0?0:Math.max(0,-parseInt(i.slice(r+1))))}};j.exports=y.extend({type:"number",flags:{unsafe:{default:!1}},coerce:{from:"string",method(e,{schema:i,error:n}){if(!e.match(f.numberRx))return;e=e.trim();const r={value:parseFloat(e)};if(0===r.value&&(r.value=0),!i._flags.unsafe)if(e.match(/e/i)){if(f.extractSignificantDigits(e)!==f.extractSignificantDigits(String(r.value)))return r.errors=n("number.unsafe"),r}else{const t=r.value.toString();if(t.match(/e/i))return r;if(t!==f.normalizeDecimal(e))return r.errors=n("number.unsafe"),r}return r}},validate(e,{schema:i,error:n,prefs:r}){if(e===1/0||e===-1/0)return{value:e,errors:n("number.infinity")};if(!d.isNumber(e))return{value:e,errors:n("number.base")};const t={value:e};if(r.convert){const o=i.$_getRule("precision");if(o){const s=Math.pow(10,o.args.limit);t.value=Math.round(t.value*s)/s}}return 0===t.value&&(t.value=0),!i._flags.unsafe&&(e>Number.MAX_SAFE_INTEGER||e<Number.MIN_SAFE_INTEGER)&&(t.errors=n("number.unsafe")),t},rules:{compare:{method:!1,validate:(e,i,{limit:n},{name:r,operator:t,args:o})=>d.compare(e,n,t)?e:i.error("number."+r,{limit:o.limit,value:e}),args:[{name:"limit",ref:!0,assert:d.isNumber,message:"must be a number"}]},greater:{method(e){return this.$_addRule({name:"greater",method:"compare",args:{limit:e},operator:">"})}},integer:{method(){return this.$_addRule("integer")},validate:(e,i)=>Math.trunc(e)-e==0?e:i.error("number.integer")},less:{method(e){return this.$_addRule({name:"less",method:"compare",args:{limit:e},operator:"<"})}},max:{method(e){return this.$_addRule({name:"max",method:"compare",args:{limit:e},operator:"<="})}},min:{method(e){return this.$_addRule({name:"min",method:"compare",args:{limit:e},operator:">="})}},multiple:{method(e){const i="number"==typeof e?f.decimalPlaces(e):null,n=Math.pow(10,i);return this.$_addRule({name:"multiple",args:{base:e,baseDecimalPlace:i,pfactor:n}})},validate:(e,i,{base:n,baseDecimalPlace:r,pfactor:t},o)=>f.decimalPlaces(e)>r?i.error("number.multiple",{multiple:o.args.base,value:e}):Math.round(t*e)%Math.round(t*n)==0?e:i.error("number.multiple",{multiple:o.args.base,value:e}),args:[{name:"base",ref:!0,assert:e=>"number"==typeof e&&isFinite(e)&&e>0,message:"must be a positive number"},"baseDecimalPlace","pfactor"],multi:!0},negative:{method(){return this.sign("negative")}},port:{method(){return this.$_addRule("port")},validate:(e,i)=>Number.isSafeInteger(e)&&e>=0&&e<=65535?e:i.error("number.port")},positive:{method(){return this.sign("positive")}},precision:{method(e){return l(Number.isSafeInteger(e),"limit must be an integer"),this.$_addRule({name:"precision",args:{limit:e}})},validate(e,i,{limit:n}){const r=e.toString().match(f.precisionRx);return Math.max((r[1]?r[1].length:0)-(r[2]?parseInt(r[2],10):0),0)<=n?e:i.error("number.precision",{limit:n,value:e})},convert:!0},sign:{method(e){return l(["negative","positive"].includes(e),"Invalid sign",e),this.$_addRule({name:"sign",args:{sign:e}})},validate:(e,i,{sign:n})=>"negative"===n&&e<0||"positive"===n&&e>0?e:i.error(`number.${n}`)},unsafe:{method(e=!0){return l("boolean"==typeof e,"enabled must be a boolean"),this.$_setFlag("unsafe",e)}}},cast:{string:{from:e=>"number"==typeof e,to:(e,i)=>e.toString()}},messages:{"number.base":"{{#label}} must be a number","number.greater":"{{#label}} must be greater than {{#limit}}","number.infinity":"{{#label}} cannot be infinity","number.integer":"{{#label}} must be an integer","number.less":"{{#label}} must be less than {{#limit}}","number.max":"{{#label}} must be less than or equal to {{#limit}}","number.min":"{{#label}} must be greater than or equal to {{#limit}}","number.multiple":"{{#label}} must be a multiple of {{#multiple}}","number.negative":"{{#label}} must be a negative number","number.port":"{{#label}} must be a valid port","number.positive":"{{#label}} must be a positive number","number.precision":"{{#label}} must have no more than {{#limit}} decimal places","number.unsafe":"{{#label}} must be a safe number"}}),f.extractSignificantDigits=function(e){return e.replace(f.exponentialPartRegex,"").replace(f.dotRegex,"").replace(f.trailingZerosRegex,"").replace(f.leadingSignAndZerosRegex,"")},f.normalizeDecimal=function(e){return(e=e.replace(/^\+/,"").replace(/\.0*$/,"").replace(/^(-?)\.([^\.]*)$/,"$10.$2").replace(/^(-?)0+([0-9])/,"$1$2")).includes(".")&&e.endsWith("0")&&(e=e.replace(/0+$/,"")),"-0"===e?"0":e}},8966:(j,$,b)=>{"use strict";const l=b(7824);j.exports=l.extend({type:"object",cast:{map:{from:y=>y&&"object"==typeof y,to:(y,d)=>new Map(Object.entries(y))}}})},7417:(j,$,b)=>{"use strict";const l=b(375),y=b(5380),d=b(1745),f=b(9959),e=b(6064),i=b(9926),n=b(5752),r=b(8068),t=b(8160),o={tlds:i instanceof Set&&{tlds:{allow:i,deny:null}},base64Regex:{true:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}==|[\w\-]{3}=)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/},false:{true:/^(?:[\w\-]{2}[\w\-]{2})*(?:[\w\-]{2}(==)?|[\w\-]{3}=?)?$/,false:/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}(==)?|[A-Za-z0-9+\/]{3}=?)?$/}},dataUriRegex:/^data:[\w+.-]+\/[\w+.-]+;((charset=[\w-]+|base64),)?(.*)$/,hexRegex:{withPrefix:/^0x[0-9a-f]+$/i,withOptionalPrefix:/^(?:0x)?[0-9a-f]+$/i,withoutPrefix:/^[0-9a-f]+$/i},ipRegex:f.regex({cidr:"forbidden"}).regex,isoDurationRegex:/^P(?!$)(\d+Y)?(\d+M)?(\d+W)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?$/,guidBrackets:{"{":"}","[":"]","(":")","":""},guidVersions:{uuidv1:"1",uuidv2:"2",uuidv3:"3",uuidv4:"4",uuidv5:"5",uuidv6:"6",uuidv7:"7",uuidv8:"8"},guidSeparators:new Set([void 0,!0,!1,"-",":"]),normalizationForms:["NFC","NFD","NFKC","NFKD"]};j.exports=r.extend({type:"string",flags:{insensitive:{default:!1},truncate:{default:!1}},terms:{replacements:{init:null}},coerce:{from:"string",method(s,{schema:a,state:c,prefs:h}){const p=a.$_getRule("normalize");p&&(s=s.normalize(p.args.form));const _=a.$_getRule("case");_&&(s="upper"===_.args.direction?s.toLocaleUpperCase():s.toLocaleLowerCase());const v=a.$_getRule("trim");if(v&&v.args.enabled&&(s=s.trim()),a.$_terms.replacements)for(const m of a.$_terms.replacements)s=s.replace(m.pattern,m.replacement);const u=a.$_getRule("hex");if(u&&u.args.options.byteAligned&&s.length%2!=0&&(s=`0${s}`),a.$_getRule("isoDate")){const m=o.isoDate(s);m&&(s=m)}if(a._flags.truncate){const m=a.$_getRule("max");if(m){let g=m.args.limit;if(t.isResolvable(g)&&(g=g.resolve(s,c,h),!t.limit(g)))return{value:s,errors:a.$_createError("any.ref",g,{ref:m.args.limit,arg:"limit",reason:"must be a positive integer"},c,h)};s=s.slice(0,g)}}return{value:s}}},validate(s,{schema:a,error:c}){if("string"!=typeof s)return{value:s,errors:c("string.base")};if(""===s){const h=a.$_getRule("min");return h&&0===h.args.limit?void 0:{value:s,errors:c("string.empty")}}},rules:{alphanum:{method(){return this.$_addRule("alphanum")},validate:(s,a)=>/^[a-zA-Z0-9]+$/.test(s)?s:a.error("string.alphanum")},base64:{method(s={}){return t.assertOptions(s,["paddingRequired","urlSafe"]),s={urlSafe:!1,paddingRequired:!0,...s},l("boolean"==typeof s.paddingRequired,"paddingRequired must be boolean"),l("boolean"==typeof s.urlSafe,"urlSafe must be boolean"),this.$_addRule({name:"base64",args:{options:s}})},validate:(s,a,{options:c})=>o.base64Regex[c.paddingRequired][c.urlSafe].test(s)?s:a.error("string.base64")},case:{method(s){return l(["lower","upper"].includes(s),"Invalid case:",s),this.$_addRule({name:"case",args:{direction:s}})},validate:(s,a,{direction:c})=>"lower"===c&&s===s.toLocaleLowerCase()||"upper"===c&&s===s.toLocaleUpperCase()?s:a.error(`string.${c}case`),convert:!0},creditCard:{method(){return this.$_addRule("creditCard")},validate(s,a){let c=s.length,h=0,p=1;for(;c--;){const _=s.charAt(c)*p;h+=_-9*(_>9),p^=3}return h>0&&h%10==0?s:a.error("string.creditCard")}},dataUri:{method(s={}){return t.assertOptions(s,["paddingRequired"]),s={paddingRequired:!0,...s},l("boolean"==typeof s.paddingRequired,"paddingRequired must be boolean"),this.$_addRule({name:"dataUri",args:{options:s}})},validate(s,a,{options:c}){const h=s.match(o.dataUriRegex);return!h||h[2]&&"base64"===h[2]&&!o.base64Regex[c.paddingRequired].false.test(h[3])?a.error("string.dataUri"):s}},domain:{method(s){s&&t.assertOptions(s,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const a=o.addressOptions(s);return this.$_addRule({name:"domain",args:{options:s},address:a})},validate:(s,a,c,{address:h})=>y.isValid(s,h)?s:a.error("string.domain")},email:{method(s={}){t.assertOptions(s,["allowFullyQualified","allowUnicode","ignoreLength","maxDomainSegments","minDomainSegments","multiple","separator","tlds"]),l(void 0===s.multiple||"boolean"==typeof s.multiple,"multiple option must be an boolean");const a=o.addressOptions(s),c=new RegExp(`\\s*[${s.separator?e(s.separator):","}]\\s*`);return this.$_addRule({name:"email",args:{options:s},regex:c,address:a})},validate(s,a,{options:c},{regex:h,address:p}){const _=c.multiple?s.split(h):[s],v=[];for(const u of _)d.isValid(u,p)||v.push(u);return v.length?a.error("string.email",{value:s,invalids:v}):s}},guid:{alias:"uuid",method(s={}){t.assertOptions(s,["version","separator"]);let a="";if(s.version){const p=[].concat(s.version);l(p.length>=1,"version must have at least 1 valid version specified");const _=new Set;for(let v=0;v<p.length;++v){const u=p[v];l("string"==typeof u,"version at position "+v+" must be a string");const m=o.guidVersions[u.toLowerCase()];l(m,"version at position "+v+" must be one of "+Object.keys(o.guidVersions).join(", ")),l(!_.has(m),"version at position "+v+" must not be a duplicate"),a+=m,_.add(m)}}l(o.guidSeparators.has(s.separator),'separator must be one of true, false, "-", or ":"');const h=new RegExp(`^([\\[{\\(]?)[0-9A-F]{8}(${void 0===s.separator?"[:-]?":!0===s.separator?"[:-]":!1===s.separator?"[]?":`\\${s.separator}`})[0-9A-F]{4}\\2?[${a||"0-9A-F"}][0-9A-F]{3}\\2?[${a?"89AB":"0-9A-F"}][0-9A-F]{3}\\2?[0-9A-F]{12}([\\]}\\)]?)$`,"i");return this.$_addRule({name:"guid",args:{options:s},regex:h})},validate(s,a,c,{regex:h}){const p=h.exec(s);return p?o.guidBrackets[p[1]]!==p[p.length-1]?a.error("string.guid"):s:a.error("string.guid")}},hex:{method(s={}){return t.assertOptions(s,["byteAligned","prefix"]),s={byteAligned:!1,prefix:!1,...s},l("boolean"==typeof s.byteAligned,"byteAligned must be boolean"),l("boolean"==typeof s.prefix||"optional"===s.prefix,'prefix must be boolean or "optional"'),this.$_addRule({name:"hex",args:{options:s}})},validate:(s,a,{options:c})=>("optional"===c.prefix?o.hexRegex.withOptionalPrefix:!0===c.prefix?o.hexRegex.withPrefix:o.hexRegex.withoutPrefix).test(s)?c.byteAligned&&s.length%2!=0?a.error("string.hexAlign"):s:a.error("string.hex")},hostname:{method(){return this.$_addRule("hostname")},validate:(s,a)=>y.isValid(s,{minDomainSegments:1})||o.ipRegex.test(s)?s:a.error("string.hostname")},insensitive:{method(){return this.$_setFlag("insensitive",!0)}},ip:{method(s={}){t.assertOptions(s,["cidr","version"]);const{cidr:a,versions:c,regex:h}=f.regex(s);return this.$_addRule({name:"ip",args:{options:{cidr:a,version:s.version?c:void 0}},regex:h})},validate:(s,a,{options:c},{regex:h})=>h.test(s)?s:c.version?a.error("string.ipVersion",{value:s,cidr:c.cidr,version:c.version}):a.error("string.ip",{value:s,cidr:c.cidr})},isoDate:{method(){return this.$_addRule("isoDate")},validate:(s,{error:a})=>o.isoDate(s)?s:a("string.isoDate")},isoDuration:{method(){return this.$_addRule("isoDuration")},validate:(s,a)=>o.isoDurationRegex.test(s)?s:a.error("string.isoDuration")},length:{method(s,a){return o.length(this,"length",s,"=",a)},validate:(s,a,{limit:c,encoding:h},{name:p,operator:_,args:v})=>t.compare(!h&&s.length,c,_)?s:a.error("string."+p,{limit:v.limit,value:s,encoding:h}),args:[{name:"limit",ref:!0,assert:t.limit,message:"must be a positive integer"},"encoding"]},lowercase:{method(){return this.case("lower")}},max:{method(s,a){return o.length(this,"max",s,"<=",a)},args:["limit","encoding"]},min:{method(s,a){return o.length(this,"min",s,">=",a)},args:["limit","encoding"]},normalize:{method(s="NFC"){return l(o.normalizationForms.includes(s),"normalization form must be one of "+o.normalizationForms.join(", ")),this.$_addRule({name:"normalize",args:{form:s}})},validate:(s,{error:a},{form:c})=>s===s.normalize(c)?s:a("string.normalize",{value:s,form:c}),convert:!0},pattern:{alias:"regex",method(s,a={}){l(s instanceof RegExp,"regex must be a RegExp"),l(!s.flags.includes("g")&&!s.flags.includes("y"),"regex should not use global or sticky mode"),"string"==typeof a&&(a={name:a}),t.assertOptions(a,["invert","name"]);const c=["string.pattern",a.invert?".invert":"",a.name?".name":".base"].join("");return this.$_addRule({name:"pattern",args:{regex:s,options:a},errorCode:c})},validate:(s,a,{regex:c,options:h},{errorCode:p})=>c.test(s)^h.invert?s:a.error(p,{name:h.name,regex:c,value:s}),args:["regex","options"],multi:!0},replace:{method(s,a){"string"==typeof s&&(s=new RegExp(e(s),"g")),l(s instanceof RegExp,"pattern must be a RegExp"),l("string"==typeof a,"replacement must be a String");const c=this.clone();return c.$_terms.replacements||(c.$_terms.replacements=[]),c.$_terms.replacements.push({pattern:s,replacement:a}),c}},token:{method(){return this.$_addRule("token")},validate:(s,a)=>/^\w+$/.test(s)?s:a.error("string.token")},trim:{method(s=!0){return l("boolean"==typeof s,"enabled must be a boolean"),this.$_addRule({name:"trim",args:{enabled:s}})},validate:(s,a,{enabled:c})=>c&&s!==s.trim()?a.error("string.trim"):s,convert:!0},truncate:{method(s=!0){return l("boolean"==typeof s,"enabled must be a boolean"),this.$_setFlag("truncate",s)}},uppercase:{method(){return this.case("upper")}},uri:{method(s={}){t.assertOptions(s,["allowRelative","allowQuerySquareBrackets","domain","relativeOnly","scheme"]),s.domain&&t.assertOptions(s.domain,["allowFullyQualified","allowUnicode","maxDomainSegments","minDomainSegments","tlds"]);const{regex:a,scheme:c}=n.regex(s),h=s.domain?o.addressOptions(s.domain):null;return this.$_addRule({name:"uri",args:{options:s},regex:a,domain:h,scheme:c})},validate(s,a,{options:c},{regex:h,domain:p,scheme:_}){if(["http:/","https:/"].includes(s))return a.error("string.uri");const v=h.exec(s);if(v){const u=v[1]||v[2];return!p||c.allowRelative&&!u||y.isValid(u,p)?s:a.error("string.domain",{value:u})}return c.relativeOnly?a.error("string.uriRelativeOnly"):c.scheme?a.error("string.uriCustomScheme",{scheme:_,value:s}):a.error("string.uri")}}},manifest:{build(s,a){if(a.replacements)for(const{pattern:c,replacement:h}of a.replacements)s=s.replace(c,h);return s}},messages:{"string.alphanum":"{{#label}} must only contain alpha-numeric characters","string.base":"{{#label}} must be a string","string.base64":"{{#label}} must be a valid base64 string","string.creditCard":"{{#label}} must be a credit card","string.dataUri":"{{#label}} must be a valid dataUri string","string.domain":"{{#label}} must contain a valid domain name","string.email":"{{#label}} must be a valid email","string.empty":"{{#label}} is not allowed to be empty","string.guid":"{{#label}} must be a valid GUID","string.hex":"{{#label}} must only contain hexadecimal characters","string.hexAlign":"{{#label}} hex decoded representation must be byte aligned","string.hostname":"{{#label}} must be a valid hostname","string.ip":"{{#label}} must be a valid ip address with a {{#cidr}} CIDR","string.ipVersion":"{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR","string.isoDate":"{{#label}} must be in iso format","string.isoDuration":"{{#label}} must be a valid ISO 8601 duration","string.length":"{{#label}} length must be {{#limit}} characters long","string.lowercase":"{{#label}} must only contain lowercase characters","string.max":"{{#label}} length must be less than or equal to {{#limit}} characters long","string.min":"{{#label}} length must be at least {{#limit}} characters long","string.normalize":"{{#label}} must be unicode normalized in the {{#form}} form","string.token":"{{#label}} must only contain alpha-numeric and underscore characters","string.pattern.base":"{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}","string.pattern.name":"{{#label}} with value {:[.]} fails to match the {{#name}} pattern","string.pattern.invert.base":"{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}","string.pattern.invert.name":"{{#label}} with value {:[.]} matches the inverted {{#name}} pattern","string.trim":"{{#label}} must not have leading or trailing whitespace","string.uri":"{{#label}} must be a valid uri","string.uriCustomScheme":"{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern","string.uriRelativeOnly":"{{#label}} must be a valid relative uri","string.uppercase":"{{#label}} must only contain uppercase characters"}}),o.addressOptions=function(s){if(!s)return o.tlds||s;if(l(void 0===s.minDomainSegments||Number.isSafeInteger(s.minDomainSegments)&&s.minDomainSegments>0,"minDomainSegments must be a positive integer"),l(void 0===s.maxDomainSegments||Number.isSafeInteger(s.maxDomainSegments)&&s.maxDomainSegments>0,"maxDomainSegments must be a positive integer"),!1===s.tlds)return s;if(!0===s.tlds||void 0===s.tlds)return l(o.tlds,"Built-in TLD list disabled"),Object.assign({},s,o.tlds);l("object"==typeof s.tlds,"tlds must be true, false, or an object");const a=s.tlds.deny;if(a)return Array.isArray(a)&&(s=Object.assign({},s,{tlds:{deny:new Set(a)}})),l(s.tlds.deny instanceof Set,"tlds.deny must be an array, Set, or boolean"),l(!s.tlds.allow,"Cannot specify both tlds.allow and tlds.deny lists"),o.validateTlds(s.tlds.deny,"tlds.deny"),s;const c=s.tlds.allow;return c?!0===c?(l(o.tlds,"Built-in TLD list disabled"),Object.assign({},s,o.tlds)):(Array.isArray(c)&&(s=Object.assign({},s,{tlds:{allow:new Set(c)}})),l(s.tlds.allow instanceof Set,"tlds.allow must be an array, Set, or boolean"),o.validateTlds(s.tlds.allow,"tlds.allow"),s):s},o.validateTlds=function(s,a){for(const c of s)l(y.isValid(c,{minDomainSegments:1,maxDomainSegments:1}),`${a} must contain valid top level domain names`)},o.isoDate=function(s){if(!t.isIsoDate(s))return null;/.*T.*[+-]\d\d$/.test(s)&&(s+="00");const a=new Date(s);return isNaN(a.getTime())?null:a.toISOString()},o.length=function(s,a,c,h,p){return l(!p||!1,"Invalid encoding:",p),s.$_addRule({name:a,method:"length",args:{limit:c,encoding:p},operator:h})}},8826:(j,$,b)=>{"use strict";const l=b(375),y=b(8068),d={};d.Map=class extends Map{slice(){return new d.Map(this)}},j.exports=y.extend({type:"symbol",terms:{map:{init:new d.Map}},coerce:{method(f,{schema:e,error:i}){const n=e.$_terms.map.get(f);return n&&(f=n),e._flags.only&&"symbol"!=typeof f?{value:f,errors:i("symbol.map",{map:e.$_terms.map})}:{value:f}}},validate(f,{error:e}){if("symbol"!=typeof f)return{value:f,errors:e("symbol.base")}},rules:{map:{method(f){f&&!f[Symbol.iterator]&&"object"==typeof f&&(f=Object.entries(f)),l(f&&f[Symbol.iterator],"Iterable must be an iterable or object");const e=this.clone(),i=[];for(const n of f){l(n&&n[Symbol.iterator],"Entry must be an iterable");const[r,t]=n;l("object"!=typeof r&&"function"!=typeof r&&"symbol"!=typeof r,"Key must not be of type object, function, or Symbol"),l("symbol"==typeof t,"Value must be a Symbol"),e.$_terms.map.set(r,t),i.push(t)}return e.valid(...i)}}},manifest:{build:(f,e)=>(e.map&&(f=f.map(e.map)),f)},messages:{"symbol.base":"{{#label}} must be a symbol","symbol.map":"{{#label}} must be one of {{#map}}"}})},8863:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(738),f=b(9621),e=b(8160),i=b(6354),n=b(493),r={result:Symbol("result")};$.entry=function(t,o,s){let a=e.defaults;s&&(l(void 0===s.warnings,"Cannot override warnings preference in synchronous validation"),l(void 0===s.artifacts,"Cannot override artifacts preference in synchronous validation"),a=e.preferences(e.defaults,s));const c=r.entry(t,o,a);l(!c.mainstay.externals.length,"Schema with external rules must use validateAsync()");const h={value:c.value};return c.error&&(h.error=c.error),c.mainstay.warnings.length&&(h.warning=i.details(c.mainstay.warnings)),c.mainstay.debug&&(h.debug=c.mainstay.debug),c.mainstay.artifacts&&(h.artifacts=c.mainstay.artifacts),h},$.entryAsync=function(){var t=N(function*(o,s,a){let c=e.defaults;a&&(c=e.preferences(e.defaults,a));const h=r.entry(o,s,c),p=h.mainstay;if(h.error)throw p.debug&&(h.error.debug=p.debug),h.error;if(p.externals.length){let v=h.value;const u=[];for(const m of p.externals){const g=m.state.path,w="link"===m.schema.type?p.links.get(m.schema):null;let x,k,R=v;const S=g.length?[v]:[],E=g.length?f(o,g):o;if(g.length){x=g[g.length-1];let D=v;for(const I of g.slice(0,-1))D=D[I],S.unshift(D);k=S[0],R=k[x]}try{const D=(M,A)=>(w||m.schema).$_createError(M,R,A,m.state,c),I=yield m.method(R,{schema:m.schema,linked:w,state:m.state,prefs:a,original:E,error:D,errorsArray:r.errorsArray,warn:(M,A)=>p.warnings.push((w||m.schema).$_createError(M,R,A,m.state,c)),message:(M,A)=>(w||m.schema).$_createError("external",R,A,m.state,c,{messages:M})});if(void 0===I||I===R)continue;if(I instanceof i.Report){if(p.tracer.log(m.schema,m.state,"rule","external","error"),u.push(I),c.abortEarly)break;continue}if(Array.isArray(I)&&I[e.symbols.errors]){if(p.tracer.log(m.schema,m.state,"rule","external","error"),u.push(...I),c.abortEarly)break;continue}k?(p.tracer.value(m.state,"rule",R,I,"external"),k[x]=I):(p.tracer.value(m.state,"rule",v,I,"external"),v=I)}catch(D){throw c.errors.label&&(D.message+=` (${m.label})`),D}}if(h.value=v,u.length)throw h.error=i.process(u,o,c),p.debug&&(h.error.debug=p.debug),h.error}if(!c.warnings&&!c.debug&&!c.artifacts)return h.value;const _={value:h.value};return p.warnings.length&&(_.warning=i.details(p.warnings)),p.debug&&(_.debug=p.debug),p.artifacts&&(_.artifacts=p.artifacts),_});return function(o,s,a){return t.apply(this,arguments)}}(),r.Mainstay=class{constructor(t,o,s){this.externals=[],this.warnings=[],this.tracer=t,this.debug=o,this.links=s,this.shadow=null,this.artifacts=null,this._snapshots=[]}snapshot(){this._snapshots.push({externals:this.externals.slice(),warnings:this.warnings.slice()})}restore(){const t=this._snapshots.pop();this.externals=t.externals,this.warnings=t.warnings}commit(){this._snapshots.pop()}},r.entry=function(t,o,s){const{tracer:a,cleanup:c}=r.tracer(o,s),_=new r.Mainstay(a,s.debug?[]:null,o._ids._schemaChain?new Map:null),u=new n([],[],{mainstay:_,schemas:o._ids._schemaChain?[{schema:o}]:null}),m=$.validate(t,o,u,s);c&&o.$_root.untrace();const g=i.process(m.errors,t,s);return{value:m.value,error:g,mainstay:_}},r.tracer=function(t,o){return t.$_root._tracer?{tracer:t.$_root._tracer._register(t)}:o.debug?(l(t.$_root.trace,"Debug mode not supported"),{tracer:t.$_root.trace()._register(t),cleanup:!0}):{tracer:r.ignore}},$.validate=function(t,o,s,a,c={}){if(o.$_terms.whens&&(o=o._generate(t,s,a).schema),o._preferences&&(a=r.prefs(o,a)),o._cache&&a.cache){const g=o._cache.get(t);if(s.mainstay.tracer.debug(s,"validate","cached",!!g),g)return g}const h=(g,w,x)=>o.$_createError(g,t,w,x||s,a),p={original:t,prefs:a,schema:o,state:s,error:h,errorsArray:r.errorsArray,warn:(g,w,x)=>s.mainstay.warnings.push(h(g,w,x)),message:(g,w)=>o.$_createError("custom",t,w,s,a,{messages:g})};s.mainstay.tracer.entry(o,s);const _=o._definition;if(_.prepare&&void 0!==t&&a.convert){const g=_.prepare(t,p);if(g){if(s.mainstay.tracer.value(s,"prepare",t,g.value),g.errors)return r.finalize(g.value,[].concat(g.errors),p);t=g.value}}if(_.coerce&&void 0!==t&&a.convert&&(!_.coerce.from||_.coerce.from.includes(typeof t))){const g=_.coerce.method(t,p);if(g){if(s.mainstay.tracer.value(s,"coerced",t,g.value),g.errors)return r.finalize(g.value,[].concat(g.errors),p);t=g.value}}const v=o._flags.empty;v&&v.$_match(r.trim(t,o),s.nest(v),e.defaults)&&(s.mainstay.tracer.value(s,"empty",t,void 0),t=void 0);const u=c.presence||o._flags.presence||(o._flags._endedSwitch?null:a.presence);if(void 0===t){if("forbidden"===u)return r.finalize(t,null,p);if("required"===u)return r.finalize(t,[o.$_createError("any.required",t,null,s,a)],p);if("optional"===u){if(o._flags.default!==e.symbols.deepDefault)return r.finalize(t,null,p);s.mainstay.tracer.value(s,"default",t,{}),t={}}}else if("forbidden"===u)return r.finalize(t,[o.$_createError("any.unknown",t,null,s,a)],p);const m=[];if(o._valids){const g=o._valids.get(t,s,a,o._flags.insensitive);if(g)return a.convert&&(s.mainstay.tracer.value(s,"valids",t,g.value),t=g.value),s.mainstay.tracer.filter(o,s,"valid",g),r.finalize(t,null,p);if(o._flags.only){const w=o.$_createError("any.only",t,{valids:o._valids.values({display:!0})},s,a);if(a.abortEarly)return r.finalize(t,[w],p);m.push(w)}}if(o._invalids){const g=o._invalids.get(t,s,a,o._flags.insensitive);if(g){s.mainstay.tracer.filter(o,s,"invalid",g);const w=o.$_createError("any.invalid",t,{invalids:o._invalids.values({display:!0})},s,a);if(a.abortEarly)return r.finalize(t,[w],p);m.push(w)}}if(_.validate){const g=_.validate(t,p);if(g&&(s.mainstay.tracer.value(s,"base",t,g.value),t=g.value,g.errors)){if(!Array.isArray(g.errors))return m.push(g.errors),r.finalize(t,m,p);if(g.errors.length)return m.push(...g.errors),r.finalize(t,m,p)}}return o._rules.length?r.rules(t,m,p):r.finalize(t,m,p)},r.rules=function(t,o,s){const{schema:a,state:c,prefs:h}=s;for(const p of a._rules){const _=a._definition.rules[p.method];if(_.convert&&h.convert){c.mainstay.tracer.log(a,c,"rule",p.name,"full");continue}let v,u=p.args;if(p._resolve.length){u=Object.assign({},u);for(const g of p._resolve){const w=_.argsByName.get(g),x=u[g].resolve(t,c,h),k=w.normalize?w.normalize(x):x,R=e.validateArg(k,null,w);if(R){v=a.$_createError("any.ref",x,{arg:g,ref:u[g],reason:R},c,h);break}u[g]=k}}v=v||_.validate(t,s,u,p);const m=r.rule(v,p);if(m.errors){if(c.mainstay.tracer.log(a,c,"rule",p.name,"error"),p.warn){c.mainstay.warnings.push(...m.errors);continue}if(h.abortEarly)return r.finalize(t,m.errors,s);o.push(...m.errors)}else c.mainstay.tracer.log(a,c,"rule",p.name,"pass"),c.mainstay.tracer.value(c,"rule",t,m.value,p.name),t=m.value}return r.finalize(t,o,s)},r.rule=function(t,o){return t instanceof i.Report?(r.error(t,o),{errors:[t],value:null}):Array.isArray(t)&&t[e.symbols.errors]?(t.forEach(s=>r.error(s,o)),{errors:t,value:null}):{errors:null,value:t}},r.error=function(t,o){return o.message&&t._setTemplate(o.message),t},r.finalize=function(t,o,s){o=o||[];const{schema:a,state:c,prefs:h}=s;if(o.length){const _=r.default("failover",void 0,o,s);void 0!==_&&(c.mainstay.tracer.value(c,"failover",t,_),t=_,o=[])}if(o.length&&a._flags.error)if("function"==typeof a._flags.error){o=a._flags.error(o),Array.isArray(o)||(o=[o]);for(const _ of o)l(_ instanceof Error||_ instanceof i.Report,"error() must return an Error object")}else o=[a._flags.error];if(void 0===t){const _=r.default("default",t,o,s);c.mainstay.tracer.value(c,"default",t,_),t=_}if(a._flags.cast&&void 0!==t){const _=a._definition.cast[a._flags.cast];if(_.from(t)){const v=_.to(t,s);c.mainstay.tracer.value(c,"cast",t,v,a._flags.cast),t=v}}if(a.$_terms.externals&&h.externals&&!1!==h._externals)for(const{method:_}of a.$_terms.externals)c.mainstay.externals.push({method:_,schema:a,state:c,label:i.label(a._flags,c,h)});const p={value:t,errors:o.length?o:null};return a._flags.result&&(p.value="strip"===a._flags.result?void 0:s.original,c.mainstay.tracer.value(c,a._flags.result,t,p.value),c.shadow(t,a._flags.result)),a._cache&&!1!==h.cache&&!a._refs.length&&a._cache.set(s.original,p),void 0===t||p.errors||void 0===a._flags.artifact||(c.mainstay.artifacts=c.mainstay.artifacts||new Map,c.mainstay.artifacts.has(a._flags.artifact)||c.mainstay.artifacts.set(a._flags.artifact,[]),c.mainstay.artifacts.get(a._flags.artifact).push(c.path)),p},r.prefs=function(t,o){const s=o===e.defaults;return s&&t._preferences[e.symbols.prefs]?t._preferences[e.symbols.prefs]:(o=e.preferences(o,t._preferences),s&&(t._preferences[e.symbols.prefs]=o),o)},r.default=function(t,o,s,a){const{schema:c,state:h,prefs:p}=a,_=c._flags[t];if(p.noDefaults||void 0===_)return o;if(h.mainstay.tracer.log(c,h,"rule",t,"full"),!_)return _;if("function"==typeof _){const v=_.length?[y(h.ancestors[0]),a]:[];try{return _(...v)}catch(u){return void s.push(c.$_createError(`any.${t}`,null,{error:u},h,p))}}return"object"!=typeof _?_:_[e.symbols.literal]?_.literal:e.isResolvable(_)?_.resolve(o,h,p):y(_)},r.trim=function(t,o){if("string"!=typeof t)return t;const s=o.$_getRule("trim");return s&&s.args.enabled?t.trim():t},r.ignore={active:!1,debug:d,entry:d,filter:d,log:d,resolve:d,value:d},r.errorsArray=function(){const t=[];return t[e.symbols.errors]=!0,t}},2036:(j,$,b)=>{"use strict";const l=b(375),y=b(9474),d=b(8160),f={};j.exports=f.Values=class{constructor(e,i){this._values=new Set(e),this._refs=new Set(i),this._lowercase=f.lowercases(e),this._override=!1}get length(){return this._values.size+this._refs.size}add(e,i){d.isResolvable(e)?this._refs.has(e)||(this._refs.add(e),i&&i.register(e)):this.has(e,null,null,!1)||(this._values.add(e),"string"==typeof e&&this._lowercase.set(e.toLowerCase(),e))}static merge(e,i,n){if(e=e||new f.Values,i){if(i._override)return i.clone();for(const r of[...i._values,...i._refs])e.add(r)}if(n)for(const r of[...n._values,...n._refs])e.remove(r);return e.length?e:null}remove(e){d.isResolvable(e)?this._refs.delete(e):(this._values.delete(e),"string"==typeof e&&this._lowercase.delete(e.toLowerCase()))}has(e,i,n,r){return!!this.get(e,i,n,r)}get(e,i,n,r){if(!this.length)return!1;if(this._values.has(e))return{value:e};if("string"==typeof e&&e&&r){const t=this._lowercase.get(e.toLowerCase());if(t)return{value:t}}if(!this._refs.size&&"object"!=typeof e)return!1;if("object"==typeof e)for(const t of this._values)if(y(t,e))return{value:t};if(i)for(const t of this._refs){const o=t.resolve(e,i,n,null,{in:!0});if(void 0===o)continue;const s=t.in&&"object"==typeof o?Array.isArray(o)?o:Object.keys(o):[o];for(const a of s)if(typeof a==typeof e)if(r&&e&&"string"==typeof e){if(a.toLowerCase()===e.toLowerCase())return{value:a,ref:t}}else if(y(a,e))return{value:a,ref:t}}return!1}override(){this._override=!0}values(e){if(e&&e.display){const i=[];for(const n of[...this._values,...this._refs])void 0!==n&&i.push(n);return i}return Array.from([...this._values,...this._refs])}clone(){const e=new f.Values(this._values,this._refs);return e._override=this._override,e}concat(e){l(!e._override,"Cannot concat override set of values");const i=new f.Values([...this._values,...e._values],[...this._refs,...e._refs]);return i._override=this._override,i}describe(){const e=[];this._override&&e.push({override:!0});for(const i of this._values.values())e.push(i&&"object"==typeof i?{value:i}:i);for(const i of this._refs.values())e.push(i.describe());return e}},f.Values.prototype[d.symbols.values]=!0,f.Values.prototype.slice=f.Values.prototype.clone,f.lowercases=function(e){const i=new Map;if(e)for(const n of e)"string"==typeof n&&i.set(n.toLowerCase(),n);return i}},978:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(1687),f=b(9621),e={};j.exports=function(i,n,r={}){if(l(i&&"object"==typeof i,"Invalid defaults value: must be an object"),l(!n||!0===n||"object"==typeof n,"Invalid source value: must be true, falsy or an object"),l("object"==typeof r,"Invalid options: must be an object"),!n)return null;if(r.shallow)return e.applyToDefaultsWithShallow(i,n,r);const t=y(i);return!0===n?t:d(t,n,{nullOverride:void 0!==r.nullOverride&&r.nullOverride,mergeArrays:!1})},e.applyToDefaultsWithShallow=function(i,n,r){const t=r.shallow;l(Array.isArray(t),"Invalid keys");const o=new Map,s=!0===n?null:new Set;for(let h of t){h=Array.isArray(h)?h:h.split(".");const p=f(i,h);p&&"object"==typeof p?o.set(p,s&&f(n,h)||p):s&&s.add(h)}const a=y(i,{},o);if(!s)return a;for(const h of s)e.reachCopy(a,n,h);return d(a,n,{nullOverride:void 0!==r.nullOverride&&r.nullOverride,mergeArrays:!1})},e.reachCopy=function(i,n,r){for(const s of r){if(!(s in n))return;const a=n[s];if("object"!=typeof a||null===a)return;n=a}const t=n;let o=i;for(let s=0;s<r.length-1;++s){const a=r[s];"object"!=typeof o[a]&&(o[a]={}),o=o[a]}o[r[r.length-1]]=t}},375:(j,$,b)=>{"use strict";const l=b(7916);j.exports=function(y,...d){if(!y)throw 1===d.length&&d[0]instanceof Error?d[0]:new l(d)}},8571:(j,$,b)=>{"use strict";const l=b(9621),y=b(4277),d=b(7043),f={needsProtoHack:new Set([y.set,y.map,y.weakSet,y.weakMap])};j.exports=f.clone=function(e,i={},n=null){if("object"!=typeof e||null===e)return e;let r=f.clone,t=n;if(i.shallow){if(!0!==i.shallow)return f.cloneWithShallow(e,i);r=c=>c}else if(t){const c=t.get(e);if(c)return c}else t=new Map;const o=y.getInternalProto(e);if(o===y.buffer)return!1;if(o===y.date)return new Date(e.getTime());if(o===y.regex)return new RegExp(e);const s=f.base(e,o,i);if(s===e)return e;if(t&&t.set(e,s),o===y.set)for(const c of e)s.add(r(c,i,t));else if(o===y.map)for(const[c,h]of e)s.set(c,r(h,i,t));const a=d.keys(e,i);for(const c of a){if("__proto__"===c)continue;if(o===y.array&&"length"===c){s.length=e.length;continue}const h=Object.getOwnPropertyDescriptor(e,c);h?h.get||h.set?Object.defineProperty(s,c,h):h.enumerable?s[c]=r(e[c],i,t):Object.defineProperty(s,c,{enumerable:!1,writable:!0,configurable:!0,value:r(e[c],i,t)}):Object.defineProperty(s,c,{enumerable:!0,writable:!0,configurable:!0,value:r(e[c],i,t)})}return s},f.cloneWithShallow=function(e,i){const n=i.shallow;(i=Object.assign({},i)).shallow=!1;const r=new Map;for(const t of n){const o=l(e,t);"object"!=typeof o&&"function"!=typeof o||r.set(o,o)}return f.clone(e,i,r)},f.base=function(e,i,n){if(!1===n.prototype)return f.needsProtoHack.has(i)?new i.constructor:i===y.array?[]:{};const r=Object.getPrototypeOf(e);if(r&&r.isImmutable)return e;if(i===y.array){const t=[];return r!==i&&Object.setPrototypeOf(t,r),t}if(f.needsProtoHack.has(i)){const t=new r.constructor;return r!==i&&Object.setPrototypeOf(t,r),t}return Object.create(r)}},9474:(j,$,b)=>{"use strict";const l=b(4277),y={mismatched:null};j.exports=function(d,f,e){return e=Object.assign({prototype:!0},e),!!y.isDeepEqual(d,f,e,[])},y.isDeepEqual=function(d,f,e,i){if(d===f)return 0!==d||1/d==1/f;const n=typeof d;if(n!==typeof f||null===d||null===f)return!1;if("function"===n){if(!e.deepFunction||d.toString()!==f.toString())return!1}else if("object"!==n)return d!=d&&f!=f;const r=y.getSharedType(d,f,!!e.prototype);switch(r){case l.buffer:return!1;case l.promise:return d===f;case l.regex:return d.toString()===f.toString();case y.mismatched:return!1}for(let t=i.length-1;t>=0;--t)if(i[t].isSame(d,f))return!0;i.push(new y.SeenEntry(d,f));try{return!!y.isDeepEqualObj(r,d,f,e,i)}finally{i.pop()}},y.getSharedType=function(d,f,e){if(e)return Object.getPrototypeOf(d)!==Object.getPrototypeOf(f)?y.mismatched:l.getInternalProto(d);const i=l.getInternalProto(d);return i!==l.getInternalProto(f)?y.mismatched:i},y.valueOf=function(d){const f=d.valueOf;if(void 0===f)return d;try{return f.call(d)}catch(e){return e}},y.hasOwnEnumerableProperty=function(d,f){return Object.prototype.propertyIsEnumerable.call(d,f)},y.isSetSimpleEqual=function(d,f){for(const e of Set.prototype.values.call(d))if(!Set.prototype.has.call(f,e))return!1;return!0},y.isDeepEqualObj=function(d,f,e,i,n){const{isDeepEqual:r,valueOf:t,hasOwnEnumerableProperty:o}=y,{keys:s,getOwnPropertySymbols:a}=Object;if(d===l.array){if(!i.part){if(f.length!==e.length)return!1;for(let v=0;v<f.length;++v)if(!r(f[v],e[v],i,n))return!1;return!0}for(const v of f)for(const u of e)if(r(v,u,i,n))return!0}else if(d===l.set){if(f.size!==e.size)return!1;if(!y.isSetSimpleEqual(f,e)){const v=new Set(Set.prototype.values.call(e));for(const u of Set.prototype.values.call(f)){if(v.delete(u))continue;let m=!1;for(const g of v)if(r(u,g,i,n)){v.delete(g),m=!0;break}if(!m)return!1}}}else if(d===l.map){if(f.size!==e.size)return!1;for(const[v,u]of Map.prototype.entries.call(f))if(void 0===u&&!Map.prototype.has.call(e,v)||!r(u,Map.prototype.get.call(e,v),i,n))return!1}else if(d===l.error&&(f.name!==e.name||f.message!==e.message))return!1;const c=t(f),h=t(e);if((f!==c||e!==h)&&!r(c,h,i,n))return!1;const p=s(f);if(!i.part&&p.length!==s(e).length&&!i.skip)return!1;let _=0;for(const v of p)if(i.skip&&i.skip.includes(v))void 0===e[v]&&++_;else if(!o(e,v)||!r(f[v],e[v],i,n))return!1;if(!i.part&&p.length-_!==s(e).length)return!1;if(!1!==i.symbols){const v=a(f),u=new Set(a(e));for(const m of v){if(!i.skip||!i.skip.includes(m))if(o(f,m)){if(!o(e,m)||!r(f[m],e[m],i,n))return!1}else if(o(e,m))return!1;u.delete(m)}for(const m of u)if(o(e,m))return!1}return!0},y.SeenEntry=class{constructor(d,f){this.obj=d,this.ref=f}isSame(d,f){return this.obj===d&&this.ref===f}}},7916:(j,$,b)=>{"use strict";const l=b(8761);j.exports=class extends Error{constructor(y){super(y.filter(d=>""!==d).map(d=>"string"==typeof d?d:d instanceof Error?d.message:l(d)).join(" ")||"Unknown error"),"function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,$.assert)}}},5277:j=>{"use strict";const $={};j.exports=function(b){if(!b)return"";let l="";for(let y=0;y<b.length;++y){const d=b.charCodeAt(y);$.isSafe(d)?l+=b[y]:l+=$.escapeHtmlChar(d)}return l},$.escapeHtmlChar=function(b){return $.namedHtml.get(b)||(b>=256?"&#"+b+";":`&#x${b.toString(16).padStart(2,"0")};`)},$.isSafe=function(b){return $.safeCharCodes.has(b)},$.namedHtml=new Map([[38,"&amp;"],[60,"&lt;"],[62,"&gt;"],[34,"&quot;"],[160,"&nbsp;"],[162,"&cent;"],[163,"&pound;"],[164,"&curren;"],[169,"&copy;"],[174,"&reg;"]]),$.safeCharCodes=function(){const b=new Set;for(let l=32;l<123;++l)(l>=97||l>=65&&l<=90||l>=48&&l<=57||32===l||46===l||44===l||45===l||58===l||95===l)&&b.add(l);return b}()},6064:j=>{"use strict";j.exports=function($){return $.replace(/[\^\$\.\*\+\-\?\=\!\:\|\\\/\(\)\[\]\{\}\,]/g,"\\$&")}},738:j=>{"use strict";j.exports=function(){}},1687:(j,$,b)=>{"use strict";const l=b(375),y=b(8571),d=b(7043),f={};j.exports=f.merge=function(e,i,n){if(l(e&&"object"==typeof e,"Invalid target value: must be an object"),l(null==i||"object"==typeof i,"Invalid source value: must be null, undefined, or an object"),!i)return e;if(n=Object.assign({nullOverride:!0,mergeArrays:!0},n),Array.isArray(i)){l(Array.isArray(e),"Cannot merge array onto an object"),n.mergeArrays||(e.length=0);for(let t=0;t<i.length;++t)e.push(y(i[t],{symbols:n.symbols}));return e}const r=d.keys(i,n);for(let t=0;t<r.length;++t){const o=r[t];if("__proto__"===o||!Object.prototype.propertyIsEnumerable.call(i,o))continue;const s=i[o];if(s&&"object"==typeof s){if(e[o]===s)continue;!e[o]||"object"!=typeof e[o]||Array.isArray(e[o])!==Array.isArray(s)||s instanceof Date||s instanceof RegExp?e[o]=y(s,{symbols:n.symbols}):f.merge(e[o],s,n)}else(null!=s||n.nullOverride)&&(e[o]=s)}return e}},9621:(j,$,b)=>{"use strict";const l=b(375),y={};j.exports=function(d,f,e){if(!1===f||null==f)return d;"string"==typeof(e=e||{})&&(e={separator:e});const i=Array.isArray(f);l(!i||!e.separator,"Separator option is not valid for array-based chain");const n=i?f:f.split(e.separator||".");let r=d;for(let t=0;t<n.length;++t){let o=n[t];const s=e.iterables&&y.iterables(r);if(Array.isArray(r)||"set"===s){const a=Number(o);Number.isInteger(a)&&(o=a<0?r.length+a:a)}if(!r||"function"==typeof r&&!1===e.functions||!s&&void 0===r[o]){l(!e.strict||t+1===n.length,"Missing segment",o,"in reach path ",f),l("object"==typeof r||!0===e.functions||"function"!=typeof r,"Invalid segment",o,"in reach path ",f),r=e.default;break}r=s?"set"===s?[...r][o]:r.get(o):r[o]}return r},y.iterables=function(d){return d instanceof Set?"set":d instanceof Map?"map":void 0}},8761:j=>{"use strict";j.exports=function(...$){try{return JSON.stringify(...$)}catch(b){return"[Cannot display object: "+b.message+"]"}}},4277:(j,$)=>{"use strict";const b={};$=j.exports={array:Array.prototype,buffer:!1,date:Date.prototype,error:Error.prototype,generic:Object.prototype,map:Map.prototype,promise:Promise.prototype,regex:RegExp.prototype,set:Set.prototype,weakMap:WeakMap.prototype,weakSet:WeakSet.prototype},b.typeMap=new Map([["[object Error]",$.error],["[object Map]",$.map],["[object Promise]",$.promise],["[object Set]",$.set],["[object WeakMap]",$.weakMap],["[object WeakSet]",$.weakSet]]),$.getInternalProto=function(l){if(Array.isArray(l))return $.array;if(l instanceof Date)return $.date;if(l instanceof RegExp)return $.regex;if(l instanceof Error)return $.error;const y=Object.prototype.toString.call(l);return b.typeMap.get(y)||$.generic}},7043:(j,$)=>{"use strict";$.keys=function(b,l={}){return!1!==l.symbols?Reflect.ownKeys(b):Object.getOwnPropertyNames(b)}},3652:(j,$,b)=>{"use strict";const l=b(375),y={};$.Sorter=class{constructor(){this._items=[],this.nodes=[]}add(d,f){const e=[].concat((f=f||{}).before||[]),i=[].concat(f.after||[]),n=f.group||"?",r=f.sort||0;l(!e.includes(n),`Item cannot come before itself: ${n}`),l(!e.includes("?"),"Item cannot come before unassociated items"),l(!i.includes(n),`Item cannot come after itself: ${n}`),l(!i.includes("?"),"Item cannot come after unassociated items"),Array.isArray(d)||(d=[d]);for(const t of d)this._items.push({seq:this._items.length,sort:r,before:e,after:i,group:n,node:t});if(!f.manual){const t=this._sort();l(t,"item","?"!==n?`added into group ${n}`:"","created a dependencies error")}return this.nodes}merge(d){Array.isArray(d)||(d=[d]);for(const e of d)if(e)for(const i of e._items)this._items.push(Object.assign({},i));this._items.sort(y.mergeSort);for(let e=0;e<this._items.length;++e)this._items[e].seq=e;const f=this._sort();return l(f,"merge created a dependencies error"),this.nodes}sort(){const d=this._sort();return l(d,"sort created a dependencies error"),this.nodes}_sort(){const d={},f=Object.create(null),e=Object.create(null);for(const o of this._items){const s=o.seq,a=o.group;e[a]=e[a]||[],e[a].push(s),d[s]=o.before;for(const c of o.after)f[c]=f[c]||[],f[c].push(s)}for(const o in d){const s=[];for(const a in d[o]){const c=d[o][a];e[c]=e[c]||[],s.push(...e[c])}d[o]=s}for(const o in f)if(e[o])for(const s of e[o])d[s].push(...f[o]);const i={};for(const o in d){const s=d[o];for(const a of s)i[a]=i[a]||[],i[a].push(o)}const n={},r=[];for(let o=0;o<this._items.length;++o){let s=o;if(i[o]){s=null;for(let a=0;a<this._items.length;++a){if(!0===n[a])continue;i[a]||(i[a]=[]);const c=i[a].length;let h=0;for(let p=0;p<c;++p)n[i[a][p]]&&++h;if(h===c){s=a;break}}}null!==s&&(n[s]=!0,r.push(s))}if(r.length!==this._items.length)return!1;const t={};for(const o of this._items)t[o.seq]=o;this._items=[],this.nodes=[];for(const o of r){const s=t[o];this.nodes.push(s.node),this._items.push(s)}return!0}},y.mergeSort=(d,f)=>d.sort===f.sort?0:d.sort<f.sort?-1:1},5380:(j,$,b)=>{"use strict";const l=b(443),y=b(2178),d={minDomainSegments:2,nonAsciiRx:/[^\x00-\x7f]/,domainControlRx:/[\x00-\x20@\:\/\\#!\$&\'\(\)\*\+,;=\?]/,tldSegmentRx:/^[a-zA-Z](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,domainSegmentRx:/^[a-zA-Z0-9](?:[a-zA-Z0-9\-]*[a-zA-Z0-9])?$/,URL:l.URL||URL};$.analyze=function(f,e={}){if(!f)return y.code("DOMAIN_NON_EMPTY_STRING");if("string"!=typeof f)throw new Error("Invalid input: domain must be a string");if(f.length>256)return y.code("DOMAIN_TOO_LONG");if(d.nonAsciiRx.test(f)){if(!1===e.allowUnicode)return y.code("DOMAIN_INVALID_UNICODE_CHARS");f=f.normalize("NFC")}if(d.domainControlRx.test(f))return y.code("DOMAIN_INVALID_CHARS");f=d.punycode(f),e.allowFullyQualified&&"."===f[f.length-1]&&(f=f.slice(0,-1));const i=e.minDomainSegments||d.minDomainSegments,n=f.split(".");if(n.length<i)return y.code("DOMAIN_SEGMENTS_COUNT");if(e.maxDomainSegments&&n.length>e.maxDomainSegments)return y.code("DOMAIN_SEGMENTS_COUNT_MAX");const r=e.tlds;if(r){const t=n[n.length-1].toLowerCase();if(r.deny&&r.deny.has(t)||r.allow&&!r.allow.has(t))return y.code("DOMAIN_FORBIDDEN_TLDS")}for(let t=0;t<n.length;++t){const o=n[t];if(!o.length)return y.code("DOMAIN_EMPTY_SEGMENT");if(o.length>63)return y.code("DOMAIN_LONG_SEGMENT");if(t<n.length-1){if(!d.domainSegmentRx.test(o))return y.code("DOMAIN_INVALID_CHARS")}else if(!d.tldSegmentRx.test(o))return y.code("DOMAIN_INVALID_TLDS_CHARS")}return null},$.isValid=function(f,e){return!$.analyze(f,e)},d.punycode=function(f){f.includes("%")&&(f=f.replace(/%/g,"%25"));try{return new d.URL(`http://${f}`).host}catch{return f}}},1745:(j,$,b)=>{"use strict";const l=b(9848),y=b(5380),d=b(2178),f={nonAsciiRx:/[^\x00-\x7f]/,encoder:new(l.TextEncoder||TextEncoder)};$.analyze=function(e,i){return f.email(e,i)},$.isValid=function(e,i){return!f.email(e,i)},f.email=function(e,i={}){if("string"!=typeof e)throw new Error("Invalid input: email must be a string");if(!e)return d.code("EMPTY_STRING");const n=!f.nonAsciiRx.test(e);if(!n){if(!1===i.allowUnicode)return d.code("FORBIDDEN_UNICODE");e=e.normalize("NFC")}const r=e.split("@");if(2!==r.length)return d.code(r.length>2?"MULTIPLE_AT_CHAR":"MISSING_AT_CHAR");const[t,o]=r;if(!t)return d.code("EMPTY_LOCAL");if(!i.ignoreLength){if(e.length>254)return d.code("ADDRESS_TOO_LONG");if(f.encoder.encode(t).length>64)return d.code("LOCAL_TOO_LONG")}return f.local(t,n)||y.analyze(o,i)},f.local=function(e,i){const n=e.split(".");for(const r of n){if(!r.length)return d.code("EMPTY_LOCAL_SEGMENT");if(i){if(!f.atextRx.test(r))return d.code("INVALID_LOCAL_CHARS")}else for(const t of r){if(f.atextRx.test(t))continue;const o=f.binary(t);if(!f.atomRx.test(o))return d.code("INVALID_LOCAL_CHARS")}}},f.binary=function(e){return Array.from(f.encoder.encode(e)).map(i=>String.fromCharCode(i)).join("")},f.atextRx=/^[\w!#\$%&'\*\+\-/=\?\^`\{\|\}~]+$/,f.atomRx=new RegExp(["(?:[\\xc2-\\xdf][\\x80-\\xbf])","(?:\\xe0[\\xa0-\\xbf][\\x80-\\xbf])|(?:[\\xe1-\\xec][\\x80-\\xbf]{2})|(?:\\xed[\\x80-\\x9f][\\x80-\\xbf])|(?:[\\xee-\\xef][\\x80-\\xbf]{2})","(?:\\xf0[\\x90-\\xbf][\\x80-\\xbf]{2})|(?:[\\xf1-\\xf3][\\x80-\\xbf]{3})|(?:\\xf4[\\x80-\\x8f][\\x80-\\xbf]{2})"].join("|"))},2178:(j,$)=>{"use strict";$.codes={EMPTY_STRING:"Address must be a non-empty string",FORBIDDEN_UNICODE:"Address contains forbidden Unicode characters",MULTIPLE_AT_CHAR:"Address cannot contain more than one @ character",MISSING_AT_CHAR:"Address must contain one @ character",EMPTY_LOCAL:"Address local part cannot be empty",ADDRESS_TOO_LONG:"Address too long",LOCAL_TOO_LONG:"Address local part too long",EMPTY_LOCAL_SEGMENT:"Address local part contains empty dot-separated segment",INVALID_LOCAL_CHARS:"Address local part contains invalid character",DOMAIN_NON_EMPTY_STRING:"Domain must be a non-empty string",DOMAIN_TOO_LONG:"Domain too long",DOMAIN_INVALID_UNICODE_CHARS:"Domain contains forbidden Unicode characters",DOMAIN_INVALID_CHARS:"Domain contains invalid character",DOMAIN_INVALID_TLDS_CHARS:"Domain contains invalid tld character",DOMAIN_SEGMENTS_COUNT:"Domain lacks the minimum required number of segments",DOMAIN_SEGMENTS_COUNT_MAX:"Domain contains too many segments",DOMAIN_FORBIDDEN_TLDS:"Domain uses forbidden TLD",DOMAIN_EMPTY_SEGMENT:"Domain contains empty dot-separated segment",DOMAIN_LONG_SEGMENT:"Domain contains dot-separated segment that is too long"},$.code=function(b){return{code:b,error:$.codes[b]}}},9959:(j,$,b)=>{"use strict";const l=b(375),y=b(5752);$.regex=function(d={}){l(void 0===d.cidr||"string"==typeof d.cidr,"options.cidr must be a string");const f=d.cidr?d.cidr.toLowerCase():"optional";l(["required","optional","forbidden"].includes(f),"options.cidr must be one of required, optional, forbidden"),l(void 0===d.version||"string"==typeof d.version||Array.isArray(d.version),"options.version must be a string or an array of string");let e=d.version||["ipv4","ipv6","ipvfuture"];Array.isArray(e)||(e=[e]),l(e.length>=1,"options.version must have at least 1 version specified");for(let r=0;r<e.length;++r)l("string"==typeof e[r],"options.version must only contain strings"),e[r]=e[r].toLowerCase(),l(["ipv4","ipv6","ipvfuture"].includes(e[r]),"options.version contains unknown version "+e[r]+" - must be one of ipv4, ipv6, ipvfuture");e=Array.from(new Set(e));const i=`(?:${e.map(r=>{if("forbidden"===f)return y.ip[r];const t=`\\/${"ipv4"===r?y.ip.v4Cidr:y.ip.v6Cidr}`;return"required"===f?`${y.ip[r]}${t}`:`${y.ip[r]}(?:${t})?`}).join("|")})`,n=new RegExp(`^${i}$`);return{cidr:f,versions:e,regex:n,raw:i}}},5752:(j,$,b)=>{"use strict";const l=b(375),y=b(6064),d={generate:function(){const f={},e="\\dA-Fa-f",i="["+e+"]",n="\\w-\\.~",r="!\\$&'\\(\\)\\*\\+,;=",t="%"+e,o=n+t+r+":@",s="["+o+"]",a="(?:0{0,2}\\d|0?[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";f.ipv4address="(?:"+a+"\\.){3}"+a;const c=i+"{1,4}",h="(?:"+c+":"+c+"|"+f.ipv4address+")",p="(?:"+c+":){6}"+h,_="::(?:"+c+":){5}"+h,v="(?:"+c+")?::(?:"+c+":){4}"+h,u="(?:(?:"+c+":){0,1}"+c+")?::(?:"+c+":){3}"+h,m="(?:(?:"+c+":){0,2}"+c+")?::(?:"+c+":){2}"+h,g="(?:(?:"+c+":){0,3}"+c+")?::"+c+":"+h,w="(?:(?:"+c+":){0,4}"+c+")?::"+h,x="(?:(?:"+c+":){0,5}"+c+")?::"+c,k="(?:(?:"+c+":){0,6}"+c+")?::";f.ipv4Cidr="(?:\\d|[1-2]\\d|3[0-2])",f.ipv6Cidr="(?:0{0,2}\\d|0?[1-9]\\d|1[01]\\d|12[0-8])",f.ipv6address="(?:"+p+"|"+_+"|"+v+"|"+u+"|"+m+"|"+g+"|"+w+"|"+x+"|"+k+")",f.ipvFuture="v"+i+"+\\.["+n+r+":]+",f.scheme="[a-zA-Z][a-zA-Z\\d+-\\.]*",f.schemeRegex=new RegExp(f.scheme);const R="["+n+t+r+":]*",E="(?:\\[(?:"+f.ipv6address+"|"+f.ipvFuture+")\\]|"+f.ipv4address+"|["+n+t+r+"]{1,255})",D="(?:"+R+"@)?"+E+"(?::\\d*)?",I="(?:"+R+"@)?("+E+")(?::\\d*)?",M=s+"*",A=s+"+",O="(?:\\/"+M+")*",C="\\/(?:"+A+O+")?",P=A+O,q="["+n+t+r+"@]+"+O;return f.hierPart="(?:(?:\\/\\/"+D+O+")|"+C+"|"+P+"|(?:\\/\\/\\/"+M+O+"))",f.hierPartCapture="(?:(?:\\/\\/"+I+O+")|"+C+"|"+P+")",f.relativeRef="(?:(?:\\/\\/"+D+O+")|"+C+"|"+q+"|)",f.relativeRefCapture="(?:(?:\\/\\/"+I+O+")|"+C+"|"+q+"|)",f.query="["+o+"\\/\\?]*(?=#|$)",f.queryWithSquareBrackets="["+o+"\\[\\]\\/\\?]*(?=#|$)",f.fragment="["+o+"\\/\\?]*",f}};d.rfc3986=d.generate(),$.ip={v4Cidr:d.rfc3986.ipv4Cidr,v6Cidr:d.rfc3986.ipv6Cidr,ipv4:d.rfc3986.ipv4address,ipv6:d.rfc3986.ipv6address,ipvfuture:d.rfc3986.ipvFuture},d.createRegex=function(f){const e=d.rfc3986,i="(?:\\?"+(f.allowQuerySquareBrackets?e.queryWithSquareBrackets:e.query)+")?(?:#"+e.fragment+")?",n=f.domain?e.relativeRefCapture:e.relativeRef;if(f.relativeOnly)return d.wrap(n+i);let r="";if(f.scheme){l(f.scheme instanceof RegExp||"string"==typeof f.scheme||Array.isArray(f.scheme),"scheme must be a RegExp, String, or Array");const s=[].concat(f.scheme);l(s.length>=1,"scheme must have at least 1 scheme specified");const a=[];for(let c=0;c<s.length;++c){const h=s[c];l(h instanceof RegExp||"string"==typeof h,"scheme at position "+c+" must be a RegExp or String"),h instanceof RegExp?a.push(h.source.toString()):(l(e.schemeRegex.test(h),"scheme at position "+c+" must be a valid scheme"),a.push(y(h)))}r=a.join("|")}const t="(?:"+(r?"(?:"+r+")":e.scheme)+":"+(f.domain?e.hierPartCapture:e.hierPart)+")";return d.wrap((f.allowRelative?"(?:"+t+"|"+n+")":t)+i,r)},d.wrap=function(f,e){return{raw:f=`(?=.)(?!https?:/(?:$|[^/]))(?!https?:///)(?!https?:[^/])${f}`,regex:new RegExp(`^${f}$`),scheme:e}},d.uriRegex=d.createRegex({}),$.regex=function(f={}){return f.scheme||f.allowRelative||f.relativeOnly||f.allowQuerySquareBrackets||f.domain?d.createRegex(f):d.uriRegex}},1447:(j,$)=>{"use strict";const b={operators:["!","^","*","/","%","+","-","<","<=",">",">=","==","!=","&&","||","??"],operatorCharacters:["!","^","*","/","%","+","-","<","=",">","&","|","?"],operatorsOrder:[["^"],["*","/","%"],["+","-"],["<","<=",">",">="],["==","!="],["&&"],["||","??"]],operatorsPrefix:["!","n"],literals:{'"':'"',"`":"`","'":"'","[":"]"},numberRx:/^(?:[0-9]*(\.[0-9]*)?){1}$/,tokenRx:/^[\w\$\#\.\@\:\{\}]+$/,symbol:Symbol("formula"),settings:Symbol("settings")};$.Parser=class{constructor(l,y={}){if(!y[b.settings]&&y.constants)for(const d in y.constants){const f=y.constants[d];if(null!==f&&!["boolean","number","string"].includes(typeof f))throw new Error(`Formula constant ${d} contains invalid ${typeof f} value type`)}this.settings=y[b.settings]?y:Object.assign({[b.settings]:!0,constants:{},functions:{}},y),this.single=null,this._parts=null,this._parse(l)}_parse(l){let y=[],d="",f=0,e=!1;const i=r=>{if(f)throw new Error("Formula missing closing parenthesis");const t=y.length?y[y.length-1]:null;if(e||d||r){if(t&&"reference"===t.type&&")"===r)return t.type="function",t.value=this._subFormula(d,t.value),void(d="");if(")"===r){const o=new $.Parser(d,this.settings);y.push({type:"segment",value:o})}else if(e){if("]"===e)return y.push({type:"reference",value:d}),void(d="");y.push({type:"literal",value:d})}else if(b.operatorCharacters.includes(d))t&&"operator"===t.type&&b.operators.includes(t.value+d)?t.value+=d:y.push({type:"operator",value:d});else if(d.match(b.numberRx))y.push({type:"constant",value:parseFloat(d)});else if(void 0!==this.settings.constants[d])y.push({type:"constant",value:this.settings.constants[d]});else{if(!d.match(b.tokenRx))throw new Error(`Formula contains invalid token: ${d}`);y.push({type:"reference",value:d})}d=""}};for(const r of l)e?r===e?(i(),e=!1):d+=r:f?"("===r?(d+=r,++f):")"===r?(--f,f?d+=r:i(r)):d+=r:r in b.literals?e=b.literals[r]:"("===r?(i(),++f):b.operatorCharacters.includes(r)?(i(),d=r,i()):" "!==r?d+=r:i();i(),y=y.map((r,t)=>"operator"!==r.type||"-"!==r.value||t&&"operator"!==y[t-1].type?r:{type:"operator",value:"n"});let n=!1;for(const r of y){if("operator"===r.type){if(b.operatorsPrefix.includes(r.value))continue;if(!n)throw new Error("Formula contains an operator in invalid position");if(!b.operators.includes(r.value))throw new Error(`Formula contains an unknown operator ${r.value}`)}else if(n)throw new Error("Formula missing expected operator");n=!n}if(!n)throw new Error("Formula contains invalid trailing operator");1===y.length&&["reference","literal","constant"].includes(y[0].type)&&(this.single={type:"reference"===y[0].type?"reference":"value",value:y[0].value}),this._parts=y.map(r=>{if("operator"===r.type)return b.operatorsPrefix.includes(r.value)?r:r.value;if("reference"!==r.type)return r.value;if(this.settings.tokenRx&&!this.settings.tokenRx.test(r.value))throw new Error(`Formula contains invalid reference ${r.value}`);return this.settings.reference?this.settings.reference(r.value):b.reference(r.value)})}_subFormula(l,y){const d=this.settings.functions[y];if("function"!=typeof d)throw new Error(`Formula contains unknown function ${y}`);let f=[];if(l){let e="",i=0,n=!1;const r=()=>{if(!e)throw new Error(`Formula contains function ${y} with invalid arguments ${l}`);f.push(e),e=""};for(let t=0;t<l.length;++t){const o=l[t];n?(e+=o,o===n&&(n=!1)):o in b.literals&&!i?(e+=o,n=b.literals[o]):","!==o||i?(e+=o,"("===o?++i:")"===o&&--i):r()}r()}return f=f.map(e=>new $.Parser(e,this.settings)),function(e){const i=[];for(const n of f)i.push(n.evaluate(e));return d.call(e,...i)}}evaluate(l){const y=this._parts.slice();for(let d=y.length-2;d>=0;--d){const f=y[d];if(f&&"operator"===f.type){const e=y[d+1];y.splice(d+1,1);const i=b.evaluate(e,l);y[d]=b.single(f.value,i)}}return b.operatorsOrder.forEach(d=>{for(let f=1;f<y.length-1;)if(d.includes(y[f])){const e=y[f],i=b.evaluate(y[f-1],l),n=b.evaluate(y[f+1],l);y.splice(f,2);const r=b.calculate(e,i,n);y[f-1]=0===r?0:r}else f+=2}),b.evaluate(y[0],l)}},$.Parser.prototype[b.symbol]=!0,b.reference=function(l){return function(y){return y&&void 0!==y[l]?y[l]:null}},b.evaluate=function(l,y){return null===l?null:"function"==typeof l?l(y):l[b.symbol]?l.evaluate(y):l},b.single=function(l,y){if("!"===l)return!y;const d=-y;return 0===d?0:d},b.calculate=function(l,y,d){if("??"===l)return b.exists(y)?y:d;if("string"==typeof y||"string"==typeof d){if("+"===l)return(y=b.exists(y)?y:"")+(b.exists(d)?d:"")}else switch(l){case"^":return Math.pow(y,d);case"*":return y*d;case"/":return y/d;case"%":return y%d;case"+":return y+d;case"-":return y-d}switch(l){case"<":return y<d;case"<=":return y<=d;case">":return y>d;case">=":return y>=d;case"==":return y===d;case"!=":return y!==d;case"&&":return y&&d;case"||":return y||d}return null},b.exists=function(l){return null!=l}},9926:()=>{},5688:()=>{},9708:()=>{},1152:()=>{},443:()=>{},9848:()=>{},5934:j=>{"use strict";j.exports=JSON.parse('{"version":"17.12.2"}')}},T={},function j($){var b=T[$];if(void 0!==b)return b.exports;var l=T[$]={exports:{}};return L[$](l,l.exports,j),l.exports}(5107))},1196:z=>{function U(N,L,T,j,$,b,l){try{var y=N[b](l),d=y.value}catch(f){return void T(f)}y.done?L(d):Promise.resolve(d).then(j,$)}z.exports=function F(N){return function(){var L=this,T=arguments;return new Promise(function(j,$){var b=N.apply(L,T);function l(d){U(b,j,$,l,y,"next",d)}function y(d){U(b,j,$,l,y,"throw",d)}l(void 0)})}},z.exports.__esModule=!0,z.exports.default=z.exports}}]);